<!DOCTYPE html>
<html lang="zh-CN" color-mode="light">

  <head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <meta name="keywords" content="" />
  <meta name="author" content="ZHI XING" />
  <meta name="description" content="" />
  
  
  <title>
    
      STL源码阅读 
      
      
      |
    
     BLOG
  </title>

  
    <link rel="apple-touch-icon" href="/images/favicon.png">
    <link rel="icon" href="/images/favicon.png">
  

  <!-- Raleway-Font -->
  <link href="https://fonts.googleapis.com/css?family=Raleway&display=swap" rel="stylesheet">

  <!-- hexo site css -->
  
<link rel="stylesheet" href="/css/color-scheme.css">
<link rel="stylesheet" href="/css/base.css">
<link rel="stylesheet" href="//at.alicdn.com/t/font_1886449_67xjft27j1l.css">
<link rel="stylesheet" href="/css/github-markdown.css">
<link rel="stylesheet" href="/css/highlight.css">
<link rel="stylesheet" href="/css/comments.css">

  <!-- 代码块风格 -->
  
    
<link rel="stylesheet" href="/css/figcaption/mac-block.css">

  

  <!-- jquery3.3.1 -->
  
    <script defer type="text/javascript" src="/plugins/jquery.min.js"></script>
  

  <!-- fancybox -->
  
    <link href="/plugins/jquery.fancybox.min.css" rel="stylesheet">
    <script defer type="text/javascript" src="/plugins/jquery.fancybox.min.js"></script>
  
  
<script src="/js/fancybox.js"></script>


  
    <!-- Global site tag (gtag.js) - Google Analytics -->
    <script async src="https://www.googletagmanager.com/gtag/js?id=G-H7TKYSEWBY"></script>
    <script>
      window.dataLayer = window.dataLayer || [];
      function gtag(){dataLayer.push(arguments);}
      gtag('js', new Date());

      gtag('config', 'G-H7TKYSEWBY');
    </script>
  

  <script>
    var html = document.documentElement
    const colorMode = localStorage.getItem('color-mode')
    if (colorMode) {
      document.documentElement.setAttribute('color-mode', colorMode)
    }
  </script>
<meta name="generator" content="Hexo 6.2.0"></head>


  <body>
    <div id="app">
      <div class="header">
  <div class="avatar">
    <a href="/">
      <!-- 头像取消懒加载，添加no-lazy -->
      
        <img src="/images/avatar.png" alt="">
      
    </a>
    <div class="nickname"><a href="/">Oranges Blogs</a></div>
  </div>
  <div class="navbar">
    <ul>
      
        <li class="nav-item" data-path="/">
          <a href="/">Home</a>
        </li>
      
        <li class="nav-item" data-path="/archives/">
          <a href="/archives/">Archives</a>
        </li>
      
        <li class="nav-item" data-path="/tags/">
          <a href="/tags/">Tags</a>
        </li>
      
        <li class="nav-item" data-path="/friends/">
          <a href="/friends/">Friends</a>
        </li>
      
        <li class="nav-item" data-path="/about/">
          <a href="/about/">About</a>
        </li>
      
    </ul>
  </div>
</div>


<script src="/js/activeNav.js"></script>



      <div class="flex-container">
        <!-- 文章详情页，展示文章具体内容，url形式：https://yoursite/文章标题/ -->
<!-- 同时为「标签tag」，「朋友friend」，「分类categories」，「关于about」页面的承载页面，具体展示取决于page.type -->


  <!-- LaTex Display -->

  
    <script async type="text/javascript" src="/plugins/mathjax/tex-chtml.js"></script>
  
  <script>
    MathJax = {
      tex: {
        inlineMath: [['$', '$'], ['\\(', '\\)']]
      }
    }
  </script>





  <!-- clipboard -->

  
    <script async type="text/javascript" src="/plugins/clipboard.min.js"></script>
  
  
<script src="/js/codeCopy.js"></script>







  

  

  

  
  <!-- 文章内容页 url形式：https://yoursite/文章标题/ -->
  <div class="container post-details" id="post-details">
    <div class="post-content">
      <div class="post-title">STL源码阅读</div>
      <div class="post-attach">
        <span class="post-pubtime">
          <i class="iconfont icon-updatetime" title="更新时间"></i>
          2022-07-05 16:15:05
        </span>
        
              <span class="post-tags">
                <i class="iconfont icon-tags" title="标签"></i>
                
                <span class="span--tag">
                  <a href="/tags/%E9%9D%A2%E8%AF%95/" title="面试">
                    <b>#</b> 面试
                  </a>
                </span>
                
                <span class="span--tag">
                  <a href="/tags/C/" title="C++">
                    <b>#</b> C++
                  </a>
                </span>
                
                <span class="span--tag">
                  <a href="/tags/STL/" title="STL">
                    <b>#</b> STL
                  </a>
                </span>
                
              </span>
          
      </div>
      <div class="markdown-body">
        <p><em>源码并非完全体 只是提取了一些关键的信息 并且为了方便观看 可能简化</em></p>
<h1 id="内存管理算法源码"><a href="#内存管理算法源码" class="headerlink" title="内存管理算法源码"></a>内存管理算法源码</h1><ol>
<li><p>uninitialized_copy(InputIterator first,InputIterator last,ForwardIterator result)<br> ”uninitialized_copy()使我们能够将记忆体的配置与物件的建构行为分离开来。如果做为输出目的地的 [result, result+(last-first)) 范围内的每一个迭代器都指向未初始化区域，则uninitialized_copy() 会 使 用 copy  constructor，为身为输入来源之 [first,last) 范围内的每一个对象产生一份复 制品，放进输出范围中。“<br> 简单来说, 将[first,last)中的内存复制到[result,…中</p>
</li>
<li><p>copy_backward(BidirectionalIterator1 first, BidirectionalIterator1 last,BidirectionalIterator2 result）<br> 简单来说，将[first,last)中的内存从last开始复制到[result,..)中，这种情况一般是当 src 与 dest 内存块有重叠时才会使用的</p>
</li>
</ol>
<h1 id="vector"><a href="#vector" class="headerlink" title="vector"></a>vector</h1><h2 id="vector类源码"><a href="#vector类源码" class="headerlink" title="vector类源码"></a>vector类源码</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 模板类 T是待存储数据类型 ALLOC是空间配置器类型</span></span><br><span class="line">templeta&lt;<span class="keyword">class</span> <span class="title class_">T</span>, <span class="keyword">class</span> <span class="title class_">Alloc</span> = alloc&gt;</span><br><span class="line"><span class="keyword">class</span> vector &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 嵌套类型定义, 这里定义了相关的数据类型,方便后面使用</span></span><br><span class="line">    <span class="keyword">typedef</span> T value_type;</span><br><span class="line">    <span class="keyword">typedef</span> value_type* pointer;</span><br><span class="line">    <span class="keyword">typedef</span> value_type&amp; reference;</span><br><span class="line">    <span class="keyword">typedef</span> value_type* iterator;</span><br><span class="line">    <span class="keyword">typedef</span> <span class="type">size_t</span> size_type;</span><br><span class="line">    <span class="keyword">typedef</span> <span class="type">ptrdiff_t</span> difference_type</span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">    <span class="comment">// 空间配置器</span></span><br><span class="line">    <span class="keyword">typedef</span> simple_alloc &lt;value_type, Alloc&gt; data_alloctor</span><br><span class="line">    <span class="comment">// 三个内存迭代器,它们管理 vector 的数据,所以 vector = 三个内存迭代器指针,共计 12 字节</span></span><br><span class="line">    iterator start;</span><br><span class="line">    iterator finish;</span><br><span class="line">    iterator end_of_storage;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 内存数据管理函数</span></span><br><span class="line">    <span class="comment">/// 1. 内存指定位置插入一个元素</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">insert_aux</span><span class="params">(iterator position, <span class="type">const</span> T&amp; x)</span></span>;</span><br><span class="line">    <span class="comment">/// 2. 回收内存</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">deallocate</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (start)</span><br><span class="line">            data_allocator::<span class="built_in">deallocate</span>(start, end_of_storage);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/// 3. 分配并填充内存</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">fill_initialize</span><span class="params">(size_type n, <span class="type">const</span> T&amp; value)</span> </span>&#123;</span><br><span class="line">        start = <span class="built_in">allocate_and_fill</span>(n, value);</span><br><span class="line">        finish = start + n;</span><br><span class="line">        end_of_storage = finish;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 对vector的操作函数一 </span></span><br><span class="line">    <span class="comment">// 注意到对应关系 v.begin() = start; v.end() = finish</span></span><br><span class="line">    <span class="function">iterator <span class="title">begin</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> start; &#125;;</span><br><span class="line">    <span class="function">iterator <span class="title">end</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> finish; &#125;;</span><br><span class="line">    <span class="function">size_type <span class="title">size</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> <span class="built_in">size_type</span>(<span class="built_in">end</span>() - <span class="built_in">begin</span>()); &#125;;</span><br><span class="line">    <span class="function">size_type <span class="title">capacity</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> <span class="built_in">size_type</span>(end_of_storage - <span class="built_in">begin</span>()); &#125;</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">empty</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> <span class="built_in">begin</span>() == <span class="built_in">end</span>(); &#125;</span><br><span class="line">    reference <span class="keyword">operator</span>[](size_type n) &#123; <span class="keyword">return</span> *(<span class="built_in">begin</span>() + n); &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// vector 构造函数</span></span><br><span class="line">    <span class="built_in">vector</span>() : <span class="built_in">start</span>(<span class="number">0</span>), <span class="built_in">end</span>(<span class="number">0</span>), <span class="built_in">end_of_storage</span>(<span class="number">0</span>) &#123;&#125;;</span><br><span class="line">    <span class="built_in">vector</span>(size_type n, <span class="type">const</span> T&amp; value)(<span class="built_in">fill_initialize</span>(n, value););</span><br><span class="line">    <span class="built_in">vector</span>(<span class="type">long</span> n, <span class="type">const</span> T&amp; value)(<span class="built_in">fill_initialize</span>(n, value););</span><br><span class="line">    <span class="built_in">vector</span>(<span class="type">int</span> n, <span class="type">const</span> T&amp; value)(<span class="built_in">fill_initialize</span>(n, value););</span><br><span class="line">    <span class="function"><span class="keyword">explicit</span> <span class="title">vector</span><span class="params">(size_type n)</span> </span>&#123; <span class="built_in">fill_initialize</span>(n, <span class="built_in">T</span>()); &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// vector 析构函数</span></span><br><span class="line">    ~<span class="built_in">vector</span>() &#123;</span><br><span class="line">        <span class="comment">// 析构对象</span></span><br><span class="line">        <span class="built_in">destory</span>(start, finish);</span><br><span class="line">        <span class="comment">// 释放空间</span></span><br><span class="line">        <span class="built_in">deallocate</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 对vector的操作函数二</span></span><br><span class="line">    <span class="comment">// 注意到对应关系 v.front() = *(v.begin()); v.back = *(v.end() - 1)</span></span><br><span class="line">    <span class="function">reference <span class="title">front</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> *<span class="built_in">begin</span>(); &#125;;</span><br><span class="line">    <span class="function">reference <span class="title">back</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> *(<span class="built_in">end</span>() - <span class="number">1</span>); &#125;;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">push_back</span><span class="params">(<span class="type">const</span> T&amp; x)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="comment">// 这里要注意 添加数据的实现 先检查空间是否足够，如果不足需要先扩展容量，再添加元素</span></span><br><span class="line">        <span class="keyword">if</span> (finsih != end_of_storage)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">construct</span>(finish, x);</span><br><span class="line">            ++finish;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="built_in">insert_aux</span>(<span class="built_in">end</span>(), x);		<span class="comment">// 容量不足,需要扩容</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">pop_back</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        --finish;</span><br><span class="line">        <span class="built_in">destory</span>(finish);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/// erase 的操作逻辑是 先将后面元素前移以覆盖 然后删除要删除的元素 所以这是一个 ON 的操作</span></span><br><span class="line">    <span class="function">iterator <span class="title">erase</span><span class="params">(iterator position)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (position + <span class="number">1</span> != <span class="built_in">end</span>())</span><br><span class="line">            <span class="built_in">copy</span>(position + <span class="number">1</span>, finish, position);</span><br><span class="line">        --finish;</span><br><span class="line">        <span class="built_in">destory</span>(finish);</span><br><span class="line">        <span class="keyword">return</span> position;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">resize</span><span class="params">(size_type new_size, <span class="type">const</span> T&amp; x)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">new_size</span>() &lt; <span class="built_in">size</span>())</span><br><span class="line">            <span class="built_in">erase</span>(<span class="built_in">begin</span>() + new_size, <span class="built_in">end</span>());</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="built_in">insert</span>(<span class="built_in">end</span>(), new_size - <span class="built_in">size</span>(), x);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">resize</span><span class="params">()</span><span class="params">(size_type new_size)</span> </span>&#123; <span class="built_in">resize</span>(new_size, <span class="built_in">T</span>()); &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">clear</span><span class="params">()</span> </span>&#123; <span class="built_in">erase</span>(<span class="built_in">begin</span>(), <span class="built_in">end</span>()); &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 空间管理</span></span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">    <span class="comment">// 配置空间并填满</span></span><br><span class="line">    <span class="function">iterator <span class="title">allocate_and_fill</span><span class="params">(size_type n, <span class="type">const</span> T&amp; x)</span> </span>&#123;</span><br><span class="line">        iterator result = data_allocator::<span class="built_in">allocate</span>(n);</span><br><span class="line">        <span class="built_in">uninitialized_fill_n</span>(result, n, x);<span class="comment">//قੴڍහ</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h2 id="vector迭代器源码"><a href="#vector迭代器源码" class="headerlink" title="vector迭代器源码"></a>vector迭代器源码</h2><ul>
<li>vector使用的是连续的内存空间，原生指针具备管理连续内存空间的能力，因而vector迭代器的本质就是原生指针<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>, <span class="keyword">class</span> <span class="title class_">Alloc</span> = alloc&gt;</span><br><span class="line"><span class="keyword">class</span> vector &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="keyword">typedef</span> T value_type;</span><br><span class="line">	<span class="keyword">typedef</span> value_type* iterator; 	<span class="comment">// vector迭代器本质就是原生指针</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li>
</ul>
<hr>
<h2 id="vector-容量拓展源码"><a href="#vector-容量拓展源码" class="headerlink" title="vector 容量拓展源码"></a>vector 容量拓展源码</h2><ul>
<li>这是当容量不足时拓展容量的函数，前文 <code>push_back</code> 中有使用<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">T</span>, <span class="keyword">class</span> <span class="title class_">Alloc</span>&gt;</span><br><span class="line"><span class="type">void</span> vector&lt;T, Alloc&gt;::<span class="built_in">insert_aux</span>(iterator position, <span class="type">const</span> T&amp; x) </span><br><span class="line">&#123;</span><br><span class="line">	<span class="comment">// 如果还有空间,直接插入就可以了</span></span><br><span class="line">	<span class="keyword">if</span> (finish != end_of_storage) </span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">consruct</span>(finish, *(finish - <span class="number">1</span>));</span><br><span class="line">		++finish;</span><br><span class="line">		T x_copy = x;</span><br><span class="line">		<span class="built_in">copy_backward</span>(position, finish - <span class="number">2</span>, finish - <span class="number">1</span>);</span><br><span class="line">		*position = x_copy;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 如果空间不足 那就要考虑扩容了</span></span><br><span class="line">	<span class="keyword">else</span> </span><br><span class="line">	&#123;</span><br><span class="line">		<span class="type">const</span> size_type old_size = <span class="built_in">size</span>();</span><br><span class="line">		<span class="comment">// 新空间长度 = 原空间长度不为0 ？ 2倍原空间长度 : 1s </span></span><br><span class="line">		<span class="type">const</span> size_type len = old_size != <span class="number">0</span> ? <span class="number">2</span> * <span class="built_in">old_size</span>() : <span class="number">1</span>;</span><br><span class="line">		iterator new_start = data_allocator::<span class="built_in">allocate</span>(len);</span><br><span class="line">		iterator new_finish = new_start;</span><br><span class="line">		<span class="keyword">try</span> </span><br><span class="line">		&#123;</span><br><span class="line">			<span class="comment">// 将原有数据拷贝到新内存中</span></span><br><span class="line">			new_finish = <span class="built_in">uninitialized_copy</span>(start, position, new_start);</span><br><span class="line">			<span class="built_in">construct</span>(new_finish, x);</span><br><span class="line">			++new_finish;</span><br><span class="line">			<span class="comment">// 添加新元素</span></span><br><span class="line">			new_finish = <span class="built_in">uninitialized_copy</span>(position, finish, new_finish);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="built_in">catch</span> () &#123;</span><br><span class="line">			<span class="built_in">destroy</span>(new_start, new_finish);</span><br><span class="line">			data_allocator::<span class="built_in">deallocate</span>(new_start, len);</span><br><span class="line">			<span class="keyword">throw</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">// 销毁原来的 vector</span></span><br><span class="line">		<span class="built_in">destory</span>(<span class="built_in">begin</span>(), <span class="built_in">end</span>());</span><br><span class="line">		<span class="built_in">deallocate</span>();</span><br><span class="line">		<span class="comment">// 调整迭代器 指向新的内存</span></span><br><span class="line">		start = new_start;</span><br><span class="line">		finish = new_finish;</span><br><span class="line">		end_of_storage = new_start + len;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<hr>
<h2 id="vector-insert函数源码"><a href="#vector-insert函数源码" class="headerlink" title="vector insert函数源码"></a>vector insert函数源码</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">T</span>, <span class="keyword">class</span> <span class="title class_">Alloc</span>&gt;</span><br><span class="line"><span class="type">void</span> vector&lt;T, Alloc&gt;::<span class="built_in">insert</span>(iterator position, size_type n, <span class="type">const</span> T&amp; x) &#123;</span><br><span class="line">	<span class="keyword">if</span> (n != <span class="number">0</span>) &#123;</span><br><span class="line">		<span class="comment">// 如果备用空间大于待插入元素所需的空间,考虑直接插入</span></span><br><span class="line">		<span class="keyword">if</span> (<span class="built_in">size_type</span>(end_of_strage - finish) &gt; n) </span><br><span class="line">		&#123;</span><br><span class="line">			T x_copy = x;</span><br><span class="line">			<span class="comment">// 首先计算插入点以后的元素个数 elems_after</span></span><br><span class="line">			<span class="type">const</span> size_type elems_after = finish - positon;</span><br><span class="line">			iterator old_finish = finish;</span><br><span class="line">			<span class="comment">// 如果 elems_after大于待插入元素个数</span></span><br><span class="line">			<span class="keyword">if</span> (elems_after &gt; n) </span><br><span class="line">			&#123;</span><br><span class="line">				<span class="comment">// 将 n个 靠后的 elems_after 元素后移 [finish-n,finish) -&gt; [finish,finish+n)</span></span><br><span class="line">				<span class="built_in">uninitialiazed_copy</span>(finish - n, finish, finish);</span><br><span class="line">				<span class="comment">// 移动 finish</span></span><br><span class="line">				finish += n;</span><br><span class="line">				<span class="built_in">copy_backward</span>(position, old_finish - n, old_finish);</span><br><span class="line">				<span class="comment">// 从 插入点 插入新的值</span></span><br><span class="line">				<span class="built_in">fill</span>(position, old_finish, x_copy);</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="comment">// 如果 elems_after小于待插入元素个数</span></span><br><span class="line">			<span class="keyword">else</span> </span><br><span class="line">			&#123;</span><br><span class="line">				<span class="built_in">uninitialiazed_fill_n</span>(finish, n - elems_after, finish);</span><br><span class="line">				finish += n - elems_after;</span><br><span class="line">				<span class="built_in">uninitialiazed_copy</span>(position, old_finish, finish);</span><br><span class="line">				finish += elems_after;</span><br><span class="line">				<span class="built_in">fill</span>(position, old_finish, x_copy);</span><br><span class="line">			&#125;</span><br><span class="line">		<span class="comment">// 如果备用空间不足</span></span><br><span class="line">		<span class="keyword">else</span> </span><br><span class="line">		&#123;</span><br><span class="line">			<span class="comment">// 新长度 = max(2倍原长度，原长度+N)</span></span><br><span class="line">			<span class="type">const</span> size_type old_size = <span class="built_in">size</span>();</span><br><span class="line">			<span class="type">const</span> size_type len = old_size + <span class="built_in">max</span>(old_size, n);</span><br><span class="line">			<span class="comment">// 配置新空间</span></span><br><span class="line">			iterator new_start = data_allocator::<span class="built_in">allocate</span>(len);</span><br><span class="line">			iterator new_finish = new_start;</span><br><span class="line">			_STL_TRY&#123;</span><br><span class="line">			<span class="comment">// 拷贝插入点之前的元素</span></span><br><span class="line"> 			new_finish = <span class="built_in">uninitialized_copy</span>(start, position, new_start);</span><br><span class="line">			<span class="comment">// 传入新元素</span></span><br><span class="line">			new_finish = uninitialized_fill_n;</span><br><span class="line">			<span class="comment">// 拷贝原插入点之后的元素</span></span><br><span class="line">			new_finish = <span class="built_in">uninitialized_copy</span>(position, finish, new_finish);</span><br><span class="line">			&#125;</span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> _STL_USE_EXCEPTIONS</span></span><br><span class="line">				<span class="built_in">catch</span> () &#123;</span><br><span class="line">				<span class="built_in">destroy</span>(new_start, new_finish);</span><br><span class="line">				data_allocator::<span class="built_in">deallocate</span>(new_start, len);</span><br><span class="line">				<span class="keyword">throw</span>;</span><br><span class="line">			&#125;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">			<span class="comment">// 释放原vector</span></span><br><span class="line">			<span class="built_in">destory</span>(<span class="built_in">begin</span>(), <span class="built_in">end</span>());</span><br><span class="line">			<span class="built_in">deallocate</span>();</span><br><span class="line">			<span class="comment">// 调整迭代器指向新的vector</span></span><br><span class="line">			start = new_start;</span><br><span class="line">			finish = new_finish;</span><br><span class="line">			end_of_storage = new_start + len;</span><br><span class="line">		&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h1 id="list"><a href="#list" class="headerlink" title="list"></a>list</h1><h2 id="list-类源码"><a href="#list-类源码" class="headerlink" title="list 类源码"></a>list 类源码</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">_Ty</span>, <span class="keyword">class</span> <span class="title class_">_Alloc</span> = allocator&lt;_Ty&gt;&gt;</span><br><span class="line"><span class="comment">// bidirectional linked list -- 官方注释 list 是一个双向链表</span></span><br><span class="line"><span class="keyword">class</span> list </span><br><span class="line">&#123; </span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	<span class="comment">// 这里在定义 node , 可以看出 list 与 node 是分离的设计</span></span><br><span class="line">	<span class="comment">// 不过这里 也出现了一个新东西 traits 萃取器</span></span><br><span class="line">    <span class="keyword">using</span> _Alty          = _Rebind_alloc_t&lt;_Alloc, _Ty&gt;;</span><br><span class="line">    <span class="keyword">using</span> _Alty_traits   = allocator_traits&lt;_Alty&gt;;</span><br><span class="line">    <span class="keyword">using</span> _Node          = _List_node&lt;_Ty, <span class="keyword">typename</span> allocator_traits&lt;_Alloc&gt;::void_pointer&gt;;</span><br><span class="line">    <span class="keyword">using</span> _Alnode        = _Rebind_alloc_t&lt;_Alloc, _Node&gt;;</span><br><span class="line">    <span class="keyword">using</span> _Alnode_traits = allocator_traits&lt;_Alnode&gt;;</span><br><span class="line">    <span class="keyword">using</span> _Nodeptr       = <span class="keyword">typename</span> _Alnode_traits::pointer;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 这里在定义数据类型 方便后续使用</span></span><br><span class="line">    <span class="keyword">using</span> value_type      = _Ty;</span><br><span class="line">    <span class="keyword">using</span> allocator_type  = _Alloc;</span><br><span class="line">    <span class="keyword">using</span> size_type       = <span class="keyword">typename</span> _Alty_traits::size_type;</span><br><span class="line">    <span class="keyword">using</span> difference_type = <span class="keyword">typename</span> _Alty_traits::difference_type;</span><br><span class="line">    <span class="keyword">using</span> pointer         = <span class="keyword">typename</span> _Alty_traits::pointer;</span><br><span class="line">    <span class="keyword">using</span> const_pointer   = <span class="keyword">typename</span> _Alty_traits::const_pointer;</span><br><span class="line">    <span class="keyword">using</span> reference       = value_type&amp;;</span><br><span class="line">    <span class="keyword">using</span> const_reference = <span class="type">const</span> value_type&amp;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">using</span> iterator                  = _List_iterator&lt;_Scary_val&gt;;</span><br><span class="line">    <span class="keyword">using</span> const_iterator            = _List_const_iterator&lt;_Scary_val&gt;;</span><br><span class="line">    <span class="keyword">using</span> _Unchecked_iterator       = _List_unchecked_iterator&lt;_Scary_val&gt;;</span><br><span class="line">    <span class="keyword">using</span> _Unchecked_const_iterator = _List_unchecked_const_iterator&lt;_Scary_val&gt;;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">// 这里看到 有两种特殊的迭代器 reverse_iterator 和 const_reverse_iterator</span></span><br><span class="line">    <span class="keyword">using</span> reverse_iterator       = _STD reverse_iterator&lt;iterator&gt;;</span><br><span class="line">    <span class="keyword">using</span> const_reverse_iterator = _STD reverse_iterator&lt;const_iterator&gt;;</span><br></pre></td></tr></table></figure>
<h2 id="list-node-源码"><a href="#list-node-源码" class="headerlink" title="list_node 源码"></a>list_node 源码</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">_Value_type</span>, <span class="keyword">class</span> <span class="title class_">_Voidptr</span>&gt;</span><br><span class="line"><span class="comment">// list node - 官方注释</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">_List_node</span> </span><br><span class="line">&#123; </span><br><span class="line">    <span class="keyword">using</span> value_type = _Value_type;</span><br><span class="line">    <span class="keyword">using</span> _Nodeptr   = _Rebind_pointer_t&lt;_Voidptr, _List_node&gt;;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 成员变量定义, 可以看到 next \ prev \ val , 进一步证明 list 是双向链表</span></span><br><span class="line">    <span class="comment">// successor node, or first element if head</span></span><br><span class="line">    _Nodeptr _Next; </span><br><span class="line">    <span class="comment">// predecessor node, or last element if head</span></span><br><span class="line">    _Nodeptr _Prev; </span><br><span class="line">    <span class="comment">// the stored value, unused if head - 官方注释 , 这里可以看出 list 是有使用虚拟头结点来方便链表操作的</span></span><br><span class="line">    _Value_type _Myval; </span><br><span class="line">	</span><br><span class="line">	<span class="comment">// 构造函数与赋值构造函数</span></span><br><span class="line">    _List_node(<span class="type">const</span> _List_node&amp;) = <span class="keyword">delete</span>;</span><br><span class="line">    _List_node&amp; <span class="keyword">operator</span>=(<span class="type">const</span> _List_node&amp;) = <span class="keyword">delete</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h1 id="trait"><a href="#trait" class="headerlink" title="trait"></a>trait</h1><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// traits for std::allocator - 官方注释 allocator 的 trait</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">_Alloc</span>&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">_Default_allocator_traits</span> </span><br><span class="line">&#123; </span><br><span class="line">    <span class="keyword">using</span> allocator_type = _Alloc;</span><br><span class="line">    <span class="keyword">using</span> value_type     = <span class="keyword">typename</span> _Alloc::value_type;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">using</span> pointer            = value_type*;</span><br><span class="line">    <span class="keyword">using</span> const_pointer      = <span class="type">const</span> value_type*;</span><br><span class="line">    <span class="keyword">using</span> void_pointer       = <span class="type">void</span>*;</span><br><span class="line">    <span class="keyword">using</span> const_void_pointer = <span class="type">const</span> <span class="type">void</span>*;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">using</span> size_type       = <span class="type">size_t</span>;</span><br><span class="line">    <span class="keyword">using</span> difference_type = <span class="type">ptrdiff_t</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 迭代器指针 的 萃取器</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">_Ty</span>&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">iterator_traits</span>&lt;_Ty*&gt; </span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">using</span> iterator_concept  = contiguous_iterator_tag;</span><br><span class="line">    <span class="keyword">using</span> iterator_category = random_access_iterator_tag;</span><br><span class="line">    <span class="keyword">using</span> value_type        = <span class="type">remove_cv_t</span>&lt;_Ty&gt;;</span><br><span class="line">    <span class="keyword">using</span> difference_type   = <span class="type">ptrdiff_t</span>;</span><br><span class="line">    <span class="keyword">using</span> pointer           = _Ty*;</span><br><span class="line">    <span class="keyword">using</span> reference         = _Ty&amp;;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 以下是简化的代码 方便观看  */</span></span><br><span class="line"><span class="comment">// 一般迭代器的 萃取器</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">I</span>&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">iterator_traits</span> </span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">typedef</span> <span class="keyword">typename</span> I::iteratorcategory iteratorcategory;</span><br><span class="line">	<span class="keyword">typedef</span> <span class="keyword">typename</span> I::valuetype valuetype;</span><br><span class="line">	<span class="keyword">typedef</span> <span class="keyword">typename</span> I::differencetype differencetype;</span><br><span class="line">	<span class="keyword">typedef</span> <span class="keyword">typename</span> I::pointer pointer;</span><br><span class="line">	<span class="keyword">typedef</span> <span class="keyword">typename</span> I::reference reference;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// 原生指针的 萃取器</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">iteratortraits</span>&lt;T&gt; </span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">typedef</span> randomaccessiteratortag iteratorcategory;</span><br><span class="line">	<span class="keyword">typedef</span> T value_type;</span><br><span class="line">	<span class="keyword">typedef</span> ptrdifft differencetype;</span><br><span class="line">	<span class="keyword">typedef</span> T *pointer;						</span><br><span class="line">	<span class="keyword">typedef</span> T &amp;reference;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// 常量指针的 萃取器</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">iteratortraits</span>&lt;<span class="type">const</span> T&gt; &#123;</span><br><span class="line">	<span class="keyword">typedef</span> randomaccessiteratortag iteratorcategory;</span><br><span class="line">	<span class="keyword">typedef</span> T valuetype; </span><br><span class="line">	<span class="keyword">typedef</span> ptrdifft differencetype;</span><br><span class="line">	<span class="keyword">typedef</span> <span class="type">const</span> T *pointer;</span><br><span class="line">	<span class="keyword">typedef</span> <span class="type">const</span> T &amp;reference;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h1 id="deque"><a href="#deque" class="headerlink" title="deque"></a>deque</h1><p><em>参考 <a target="_blank" rel="noopener" href="https://blog.csdn.net/ZLP_CSDN/article/details/104382886">https://blog.csdn.net/ZLP_CSDN/article/details/104382886</a></em></p>
<h2 id="deque-类源码"><a href="#deque-类源码" class="headerlink" title="deque 类源码"></a>deque 类源码</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* deque val */</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">_Val_types</span>&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">_Deque_val</span> : <span class="keyword">public</span> _Container_base12 &#123;</span><br><span class="line">	<span class="comment">// ..一些数据类型定义..</span></span><br><span class="line">	</span><br><span class="line">	<span class="comment">// 敲定容量大小</span></span><br><span class="line">	<span class="comment">// 官方注释 _Bytes &gt; 8 then elements per block (a power of 2),当元素大小大于8的时候 每一块buff只装一个元素</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">static</span> <span class="keyword">constexpr</span> <span class="type">size_t</span> _Bytes = <span class="built_in">sizeof</span>(value_type);</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">static</span> <span class="keyword">constexpr</span> <span class="type">int</span> _Block_size = _Bytes &lt;= <span class="number">1</span> ? <span class="number">16</span></span><br><span class="line">                                     : _Bytes &lt;= <span class="number">2</span> ? <span class="number">8</span></span><br><span class="line">                                     : _Bytes &lt;= <span class="number">4</span> ? <span class="number">4</span></span><br><span class="line">                                     : _Bytes &lt;= <span class="number">8</span> ? <span class="number">2</span></span><br><span class="line">                                                   : <span class="number">1</span>; </span><br><span class="line">	<span class="comment">// ...</span></span><br><span class="line">	</span><br><span class="line">	<span class="comment">// 数据成员,以下英文为官方注释</span></span><br><span class="line">	<span class="comment">/// map 指针</span></span><br><span class="line">    _Mapptr _Map; 		<span class="comment">// pointer to array of pointers to blocks</span></span><br><span class="line">    <span class="comment">// map 数组的大小 要么为0 要么是 2的倍数</span></span><br><span class="line">    size_type _Mapsize; <span class="comment">// size of map array, zero or 2^N</span></span><br><span class="line">    <span class="comment">// 第一个元素的偏移</span></span><br><span class="line">    size_type _Myoff; 	<span class="comment">// offset of initial element</span></span><br><span class="line">    <span class="comment">// 当前 deque 的 size</span></span><br><span class="line">    size_type _Mysize; 	<span class="comment">// current length of sequence</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="deque-迭代器源码"><a href="#deque-迭代器源码" class="headerlink" title="deque 迭代器源码"></a>deque 迭代器源码</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">_Mydeque</span>&gt; </span><br><span class="line"><span class="keyword">class</span> <span class="title class_">_Deque_const_iterator</span> : <span class="keyword">public</span> _Iterator_base12</span><br><span class="line">&#123;</span><br><span class="line">	_Size_type _Myoff;			<span class="comment">// offset of element in deque</span></span><br><span class="line">	<span class="type">const</span> _Mydeque *_Mycont;	<span class="comment">// pointer to deque</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">_Mydeque</span>&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">_Deque_iterator</span> : <span class="keyword">public</span> _Deque_const_iterator&lt;_Mydeque&gt;</span><br></pre></td></tr></table></figure>

<h2 id="deque-的插入函数源码"><a href="#deque-的插入函数源码" class="headerlink" title="deque 的插入函数源码"></a>deque 的插入函数源码</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">iterator <span class="title">insert</span><span class="params">(const_iterator _Where, _Ty&amp;&amp; _Val)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="built_in">emplace</span>(_Where, _STD <span class="built_in">move</span>(_Val));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">iterator <span class="title">emplace</span><span class="params">(const_iterator _Where, _Valty&amp;&amp;... _Val)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="type">const</span> <span class="keyword">auto</span> _Off = <span class="built_in">static_cast</span>&lt;size_type&gt;(_Where - <span class="built_in">begin</span>());</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 官方注释 closer to front, push to front then rotate</span></span><br><span class="line">	<span class="comment">// 如果插入点离数组头更近,先把 待插入元素放到数组头前面,然后在数组头和插入点之间做&quot;循环移位&quot;,把待插入元素移动到最近的区域</span></span><br><span class="line">	<span class="keyword">if</span> (_Off &lt;= _Mysize() / <span class="number">2</span>) </span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">emplace_front</span>(_STD forward&lt;_Valty&gt;(_Val)...);</span><br><span class="line">		<span class="function">_STD <span class="title">rotate</span><span class="params">(begin(), _Next_iter(begin()), begin() + <span class="keyword">static_cast</span>&lt;difference_type&gt;(<span class="number">1</span> + _Off))</span></span>;</span><br><span class="line">	&#125; </span><br><span class="line">	<span class="comment">// 官方注释 closer to back, push to back then rotate</span></span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">emplace_back</span>(_STD forward&lt;_Valty&gt;(_Val)...);</span><br><span class="line">		<span class="function">_STD <span class="title">rotate</span><span class="params">(begin() + <span class="keyword">static_cast</span>&lt;difference_type&gt;(_Off), _Prev_iter(end()), end())</span></span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="built_in">begin</span>() + <span class="built_in">static_cast</span>&lt;difference_type&gt;(_Off);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="deque-的-begin-和-end-迭代器源码分析"><a href="#deque-的-begin-和-end-迭代器源码分析" class="headerlink" title="deque 的 begin() 和 end() 迭代器源码分析"></a>deque 的 begin() 和 end() 迭代器源码分析</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">_NODISCARD iterator <span class="title">begin</span><span class="params">()</span> <span class="keyword">noexcept</span></span></span><br><span class="line"><span class="function"></span>&#123;	</span><br><span class="line">	<span class="keyword">return</span> (<span class="built_in">iterator</span>(<span class="keyword">this</span>-&gt;_Myoff(), _STD <span class="built_in">addressof</span>(<span class="keyword">this</span>-&gt;_Get_data())));</span><br><span class="line">	<span class="comment">// 显然 myoff 与 mysize 合作,存储者数据</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">_NODISCARD iterator <span class="title">end</span><span class="params">()</span> <span class="keyword">noexcept</span></span></span><br><span class="line"><span class="function"></span>&#123;	</span><br><span class="line">	<span class="keyword">return</span> (<span class="built_in">iterator</span>(<span class="keyword">this</span>-&gt;_Myoff() + <span class="keyword">this</span>-&gt;_Mysize(),_STD <span class="built_in">addressof</span>(<span class="keyword">this</span>-&gt;_Get_data())));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="deque-迭代器-函数源码"><a href="#deque-迭代器-函数源码" class="headerlink" title="deque 迭代器 * 函数源码"></a>deque 迭代器 * 函数源码</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// get container pointer</span></span><br><span class="line"><span class="comment">// 获取 deque 的 内存区域</span></span><br><span class="line"><span class="type">const</span> _Container_base12 *_Getcont() <span class="type">const</span></span><br><span class="line">&#123;	</span><br><span class="line">	<span class="keyword">return</span> (_Mycont);</span><br><span class="line">&#125;	</span><br><span class="line">	</span><br><span class="line">_NODISCARD reference <span class="keyword">operator</span>*() <span class="type">const</span></span><br><span class="line">&#123;	</span><br><span class="line">	<span class="comment">// 先获取内存</span></span><br><span class="line">	<span class="type">const</span> <span class="keyword">auto</span> _Mycont = <span class="built_in">static_cast</span>&lt;<span class="type">const</span> _Mydeque *&gt;(<span class="keyword">this</span>-&gt;_Getcont());</span><br><span class="line">	<span class="comment">// 再获取所在内存块</span></span><br><span class="line">	_Size_type _Block = _Mycont-&gt;_Getblock(_Myoff);</span><br><span class="line">	<span class="comment">// 然后计算块内偏移</span></span><br><span class="line">	_Size_type _Off = _Myoff % _DEQUESIZ;</span><br><span class="line">	<span class="keyword">return</span> (_Mycont-&gt;_Map[_Block][_Off]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h1 id="stack"><a href="#stack" class="headerlink" title="stack"></a>stack</h1><h2 id="stack-类源码"><a href="#stack-类源码" class="headerlink" title="stack 类源码"></a>stack 类源码</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 从类模板可以看到 Container = deque , stack 的底层就是通过 deque 来实现的</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">_Ty</span>, <span class="keyword">class</span> <span class="title class_">_Container</span> = deque&lt;_Ty&gt;&gt;</span><br><span class="line"><span class="keyword">class</span> stack </span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="comment">// 型别定义	</span></span><br><span class="line">    <span class="keyword">using</span> value_type      = <span class="keyword">typename</span> _Container::value_type;</span><br><span class="line">    <span class="keyword">using</span> reference       = <span class="keyword">typename</span> _Container::reference;</span><br><span class="line">    <span class="keyword">using</span> const_reference = <span class="keyword">typename</span> _Container::const_reference;</span><br><span class="line">    <span class="keyword">using</span> size_type       = <span class="keyword">typename</span> _Container::size_type;</span><br><span class="line">    <span class="keyword">using</span> container_type  = _Container;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 这里可以看到 deque 作为类成员变量存在于 stack 中</span></span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">    _Container c&#123;&#125;;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// ... 各种构造函数 ... </span></span><br><span class="line">	</span><br><span class="line">	<span class="comment">// 以下是 操作函数 , 可以发现其实质都是转化为了对 deque 的操作 </span></span><br><span class="line">	<span class="comment">/// empty</span></span><br><span class="line">    <span class="function">_NODISCARD <span class="type">bool</span> <span class="title">empty</span><span class="params">()</span> <span class="type">const</span> <span class="title">noexcept</span><span class="params">(<span class="keyword">noexcept</span>(c.empty()))</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> c.<span class="built_in">empty</span>();</span><br><span class="line">    &#125;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">/// size</span></span><br><span class="line">    <span class="function">_NODISCARD size_type <span class="title">size</span><span class="params">()</span> <span class="type">const</span> <span class="title">noexcept</span><span class="params">(<span class="keyword">noexcept</span>(c.size()))</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> c.<span class="built_in">size</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/// top</span></span><br><span class="line">    <span class="function">_NODISCARD reference <span class="title">top</span><span class="params">()</span> <span class="title">noexcept</span><span class="params">(<span class="keyword">noexcept</span>(c.back()))</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> c.<span class="built_in">back</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">_NODISCARD const_reference <span class="title">top</span><span class="params">()</span> <span class="type">const</span> <span class="title">noexcept</span><span class="params">(<span class="keyword">noexcept</span>(c.back()))</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> c.<span class="built_in">back</span>();</span><br><span class="line">    &#125;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">/// push</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">push</span><span class="params">(<span class="type">const</span> value_type&amp; _Val)</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        c.<span class="built_in">push_back</span>(_Val);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">push</span><span class="params">(value_type&amp;&amp; _Val)</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        c.<span class="built_in">push_back</span>(_STD <span class="built_in">move</span>(_Val));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/// pop</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">pop</span><span class="params">()</span> <span class="title">noexcept</span><span class="params">(<span class="keyword">noexcept</span>(c.pop_back()))</span> <span class="comment">/* strengthened */</span> </span>&#123;</span><br><span class="line">        c.<span class="built_in">pop_back</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/// swap</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">swap</span><span class="params">(stack&amp; _Right)</span> <span class="title">noexcept</span><span class="params">(_Is_nothrow_swappable&lt;_Container&gt;::value)</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        _Swap_adl(c, _Right.c);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">	<span class="comment">// emplace</span></span><br><span class="line">	<span class="keyword">template</span> &lt;<span class="keyword">class</span>... _Valty&gt;</span><br><span class="line">    <span class="function"><span class="keyword">decltype</span>(<span class="keyword">auto</span>) <span class="title">emplace</span><span class="params">(_Valty&amp;&amp;... _Val)</span> </span>&#123;</span><br><span class="line"><span class="meta">#<span class="keyword">if</span> _HAS_CXX17</span></span><br><span class="line">        <span class="keyword">return</span> c.<span class="built_in">emplace_back</span>(_STD forward&lt;_Valty&gt;(_Val)...);</span><br><span class="line"><span class="meta">#<span class="keyword">else</span> <span class="comment">// ^^^ C++17 or newer / C++14 vvv</span></span></span><br><span class="line">        c.<span class="built_in">emplace_back</span>(_STD forward&lt;_Valty&gt;(_Val)...);</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span> <span class="comment">// _HAS_CXX17</span></span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">	<span class="comment">/// 甚至可以直接获取到 deque, 不过是 const 的 只能访问</span></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">		stack&lt;int&gt; st;</span></span><br><span class="line"><span class="comment">		deque&lt;int&gt; dq = st._Get_container();</span></span><br><span class="line"><span class="comment">		st._Get_container().push_back(1);	// error </span></span><br><span class="line"><span class="comment">	*/</span></span><br><span class="line">	 _NODISCARD <span class="type">const</span> _Container&amp; _Get_container() <span class="type">const</span> <span class="keyword">noexcept</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> c;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<hr>
<h1 id="queue"><a href="#queue" class="headerlink" title="queue"></a>queue</h1><h2 id="queue-类源码"><a href="#queue-类源码" class="headerlink" title="queue 类源码"></a>queue 类源码</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 从类模板可以看到 Container = deque , queuw 的底层就是通过 deque 来实现的</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">_Ty</span>, <span class="keyword">class</span> <span class="title class_">_Container</span> = deque&lt;_Ty&gt;&gt;</span><br><span class="line"><span class="keyword">class</span> queue </span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="comment">// 型别定义</span></span><br><span class="line">    <span class="keyword">using</span> value_type      = <span class="keyword">typename</span> _Container::value_type;</span><br><span class="line">    <span class="keyword">using</span> reference       = <span class="keyword">typename</span> _Container::reference;</span><br><span class="line">    <span class="keyword">using</span> const_reference = <span class="keyword">typename</span> _Container::const_reference;</span><br><span class="line">    <span class="keyword">using</span> size_type       = <span class="keyword">typename</span> _Container::size_type;</span><br><span class="line">    <span class="keyword">using</span> container_type  = _Container;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">// container deque 以成员变量的形式呈现</span></span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">    _Container c&#123;&#125;;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// ... 各种构造函数 ...</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">/// 以下是操作函数,都在转化为了对于 deue 的操作</span></span><br><span class="line">    <span class="comment">/// empty</span></span><br><span class="line">    <span class="function">_NODISCARD <span class="type">bool</span> <span class="title">empty</span><span class="params">()</span> <span class="type">const</span> <span class="title">noexcept</span><span class="params">(<span class="keyword">noexcept</span>(c.empty()))</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> c.<span class="built_in">empty</span>();</span><br><span class="line">    &#125;</span><br><span class="line">	<span class="comment">/// size</span></span><br><span class="line">    <span class="function">_NODISCARD size_type <span class="title">size</span><span class="params">()</span> <span class="type">const</span> <span class="title">noexcept</span><span class="params">(<span class="keyword">noexcept</span>(c.size()))</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> c.<span class="built_in">size</span>();</span><br><span class="line">    &#125;</span><br><span class="line">	<span class="comment">/// front</span></span><br><span class="line">    <span class="function">_NODISCARD reference <span class="title">front</span><span class="params">()</span> <span class="title">noexcept</span><span class="params">(<span class="keyword">noexcept</span>(c.front()))</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> c.<span class="built_in">front</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">_NODISCARD const_reference <span class="title">front</span><span class="params">()</span> <span class="type">const</span> <span class="title">noexcept</span><span class="params">(<span class="keyword">noexcept</span>(c.front()))</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> c.<span class="built_in">front</span>();</span><br><span class="line">    &#125;</span><br><span class="line">	<span class="comment">/// back</span></span><br><span class="line">    <span class="function">_NODISCARD reference <span class="title">back</span><span class="params">()</span> <span class="title">noexcept</span><span class="params">(<span class="keyword">noexcept</span>(c.back()))</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> c.<span class="built_in">back</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">_NODISCARD const_reference <span class="title">back</span><span class="params">()</span> <span class="type">const</span> <span class="title">noexcept</span><span class="params">(<span class="keyword">noexcept</span>(c.back()))</span> 	</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> c.<span class="built_in">back</span>();</span><br><span class="line">    &#125;</span><br><span class="line">	<span class="comment">/// push</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">push</span><span class="params">(<span class="type">const</span> value_type&amp; _Val)</span> </span>&#123;</span><br><span class="line">        c.<span class="built_in">push_back</span>(_Val);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">push</span><span class="params">(value_type&amp;&amp; _Val)</span> </span>&#123;</span><br><span class="line">        c.<span class="built_in">push_back</span>(_STD <span class="built_in">move</span>(_Val));</span><br><span class="line">    &#125;</span><br><span class="line">	<span class="comment">/// pop</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">pop</span><span class="params">()</span> <span class="title">noexcept</span><span class="params">(<span class="keyword">noexcept</span>(c.pop_front()))</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        c.<span class="built_in">pop_front</span>();</span><br><span class="line">    &#125;</span><br><span class="line">	<span class="comment">/// swap</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">swap</span><span class="params">(queue&amp; _Right)</span> <span class="title">noexcept</span><span class="params">(_Is_nothrow_swappable&lt;_Container&gt;::value)</span> </span>&#123;</span><br><span class="line">        _Swap_adl(c, _Right.c);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/// emplace</span></span><br><span class="line">    <span class="keyword">template</span> &lt;<span class="keyword">class</span>... _Valty&gt;</span><br><span class="line">    <span class="function"><span class="keyword">decltype</span>(<span class="keyword">auto</span>) <span class="title">emplace</span><span class="params">(_Valty&amp;&amp;... _Val)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line"><span class="meta">#<span class="keyword">if</span> _HAS_CXX17</span></span><br><span class="line">        <span class="keyword">return</span> c.<span class="built_in">emplace_back</span>(_STD forward&lt;_Valty&gt;(_Val)...);</span><br><span class="line"><span class="meta">#<span class="keyword">else</span> <span class="comment">// ^^^ C++17 or newer / C++14 vvv</span></span></span><br><span class="line">        c.<span class="built_in">emplace_back</span>(_STD forward&lt;_Valty&gt;(_Val)...);</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span> <span class="comment">// _HAS_CXX17</span></span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">	<span class="comment">/// 甚至可以直接拿到 deque, 不过是 const 的 只能访问</span></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">		queue&lt;int&gt; q;</span></span><br><span class="line"><span class="comment">		deque&lt;int&gt; dq = q._Get_container();</span></span><br><span class="line"><span class="comment">		q._Get_container().push_back(1);	// error</span></span><br><span class="line"><span class="comment">	*/</span></span><br><span class="line">    _NODISCARD <span class="type">const</span> _Container&amp; _Get_container() <span class="type">const</span> <span class="keyword">noexcept</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> c;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h1 id="heap"><a href="#heap" class="headerlink" title="heap"></a>heap</h1><p><strong>heap 不是容器，没有类 它是通过堆算法来体现的</strong><br><strong><code>push_heap</code></strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">_RanIt</span>&gt;</span><br><span class="line"><span class="function">_CONSTEXPR20 <span class="type">void</span> <span class="title">push_heap</span><span class="params">(_RanIt _First, _RanIt _Last)</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// push *(_Last - 1) onto heap at [_First, _Last - 1)</span></span><br><span class="line">    <span class="function">_STD <span class="title">push_heap</span><span class="params">(_First, _Last, less&lt;&gt;&#123;&#125;)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<p>**由于 heap 是 有序的， 所以大部分相关函数都有一个默认less比较器的版本 和 一个可自己指定比较器的版本 **</p>
<hr>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">_RanIt</span>, <span class="keyword">class</span> <span class="title class_">_Pr</span>&gt;</span><br><span class="line"><span class="function">_CONSTEXPR20 <span class="type">void</span> <span class="title">push_heap</span><span class="params">(_RanIt _First, _RanIt _Last, _Pr _Pred)</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// push *(_Last - 1) onto heap at [_First, _Last - 1)</span></span><br><span class="line">    _Adl_verify_range(_First, _Last);</span><br><span class="line">    <span class="type">const</span> <span class="keyword">auto</span> _UFirst = _Get_unwrapped(_First);</span><br><span class="line">    <span class="keyword">auto</span> _ULast        = _Get_unwrapped(_Last);</span><br><span class="line">    <span class="keyword">using</span> _Diff        = _Iter_diff_t&lt;_RanIt&gt;;</span><br><span class="line">    _Diff _Count       = _ULast - _UFirst;</span><br><span class="line">    <span class="keyword">if</span> (<span class="number">2</span> &lt;= _Count)</span><br><span class="line">    &#123;</span><br><span class="line">        _Iter_value_t&lt;_RanIt&gt; _Val = _STD <span class="built_in">move</span>(*--_ULast);</span><br><span class="line">        _Push_heap_by_index(_UFirst, --_Count, _Diff(<span class="number">0</span>), _STD <span class="built_in">move</span>(_Val), _Pass_fn(_Pred));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">_RanIt</span>, <span class="keyword">class</span> <span class="title class_">_Ty</span>, <span class="keyword">class</span> <span class="title class_">_Pr</span>&gt;</span><br><span class="line">_CONSTEXPR20 <span class="type">void</span> _Push_heap_by_index(_RanIt _First, _Iter_diff_t&lt;_RanIt&gt; _Hole, _Iter_diff_t&lt;_RanIt&gt; _Top, _Ty&amp;&amp; _Val, _Pr _Pred) </span><br><span class="line">&#123;</span><br><span class="line">	<span class="comment">// 官方注释 ： percolate _Hole to _Top or where _Val belongs</span></span><br><span class="line">	<span class="comment">// 将 hole 渗透到 top 或者 val 适合的位置</span></span><br><span class="line">    <span class="keyword">using</span> _Diff = _Iter_diff_t&lt;_RanIt&gt;;</span><br><span class="line">    <span class="comment">// 此处</span></span><br><span class="line">    <span class="comment">// 循环变量 idx = (hole - 1) /2  , hole = idx 找到父节点</span></span><br><span class="line">    <span class="comment">// 循环条件 top &lt; hole 防止越界 和 父节点优先级低于子节点</span></span><br><span class="line">    <span class="keyword">for</span> (_Diff _Idx = (_Hole - <span class="number">1</span>) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">         _Top &lt; _Hole &amp;&amp; _DEBUG_LT_PRED(_Pred, *(_First + _Idx), _Val); </span><br><span class="line">		_Idx = (_Hole - <span class="number">1</span>) &gt;&gt; <span class="number">1</span>) </span><br><span class="line">	&#123; </span><br><span class="line">		<span class="comment">// 交换 父子节点的值</span></span><br><span class="line">        *(_First + _Hole) = _STD <span class="built_in">move</span>(*(_First + _Idx));</span><br><span class="line">        _Hole             = _Idx;</span><br><span class="line">    &#125;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">// 官方注释 ： drop _Val into final hole</span></span><br><span class="line">	<span class="comment">// 把 val 放进最后找到的合适的位置</span></span><br><span class="line">    *(_First + _Hole) = _STD forward&lt;_Ty&gt;(_Val);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<p><strong><code>pop_heap</code></strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">_RanIt</span>&gt;</span><br><span class="line"><span class="function">_CONSTEXPR20 <span class="type">void</span> <span class="title">pop_heap</span><span class="params">(_RanIt _First, _RanIt _Last)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 官方注释: pop *_First to *(_Last - 1) and reheap</span></span><br><span class="line">    <span class="comment">// 把 first 放到 last - 1; 然后重建 heap</span></span><br><span class="line">    <span class="comment">// 这里可以看出,默认是 less 的比较器</span></span><br><span class="line">    <span class="function">_STD <span class="title">pop_heap</span><span class="params">(_First, _Last, less&lt;&gt;&#123;&#125;)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">_RanIt</span>, <span class="keyword">class</span> <span class="title class_">_Pr</span>&gt;</span><br><span class="line"><span class="function">_CONSTEXPR20 <span class="type">void</span> <span class="title">pop_heap</span><span class="params">(_RanIt _First, _RanIt _Last, _Pr _Pred)</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 官方注释 ： pop *_First to *(_Last - 1) and reheap</span></span><br><span class="line">    <span class="comment">// 这里可以看到 可以指定比较器, 而且 上面那个pop_heap 是通过调用这个 pop_heap来实现的</span></span><br><span class="line">    _Adl_verify_range(_First, _Last);</span><br><span class="line">    _Pop_heap_unchecked(_Get_unwrapped(_First), _Get_unwrapped(_Last), _Pass_fn(_Pred));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">_RanIt</span>, <span class="keyword">class</span> <span class="title class_">_Pr</span>&gt;</span><br><span class="line">_CONSTEXPR20 <span class="type">void</span> _Pop_heap_unchecked(_RanIt _First, _RanIt _Last, _Pr _Pred) </span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// pop *_First to *(_Last - 1) and reheap</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="number">2</span> &lt;= _Last - _First)</span><br><span class="line">    &#123;</span><br><span class="line">        --_Last;</span><br><span class="line">        _Iter_value_t&lt;_RanIt&gt; _Val = _STD <span class="built_in">move</span>(*_Last);</span><br><span class="line">        <span class="comment">// 拿到新 堆顶 的 val , 方便后面调整堆</span></span><br><span class="line">        _Pop_heap_hole_unchecked(_First, _Last, _Last, _STD <span class="built_in">move</span>(_Val), _Pred);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">_RanIt</span>, <span class="keyword">class</span> <span class="title class_">_Ty</span>, <span class="keyword">class</span> <span class="title class_">_Pr</span>&gt;</span><br><span class="line">_CONSTEXPR20 <span class="type">void</span> _Pop_heap_hole_unchecked(_RanIt _First, _RanIt _Last, _RanIt _Dest, _Ty&amp;&amp; _Val, _Pr _Pred) </span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// pop *_First to *_Dest and reheap</span></span><br><span class="line">    <span class="comment">// precondition: _First != _Last</span></span><br><span class="line">    <span class="comment">// precondition: _First != _Dest</span></span><br><span class="line">    *_Dest      = _STD <span class="built_in">move</span>(*_First);</span><br><span class="line">    <span class="keyword">using</span> _Diff = _Iter_diff_t&lt;_RanIt&gt;;</span><br><span class="line">    _Pop_heap_hole_by_index(</span><br><span class="line">        _First, <span class="built_in">static_cast</span>&lt;_Diff&gt;(<span class="number">0</span>), <span class="built_in">static_cast</span>&lt;_Diff&gt;(_Last - _First), _STD forward&lt;_Ty&gt;(_Val), _Pred);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">_RanIt</span>, <span class="keyword">class</span> <span class="title class_">_Ty</span>, <span class="keyword">class</span> <span class="title class_">_Pr</span>&gt;</span><br><span class="line">_CONSTEXPR20 <span class="type">void</span> _Pop_heap_hole_by_index(_RanIt _First, _Iter_diff_t&lt;_RanIt&gt; _Hole, _Iter_diff_t&lt;_RanIt&gt; _Bottom, _Ty&amp;&amp; _Val, _Pr _Pred)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// percolate _Hole to _Bottom, then push _Val</span></span><br><span class="line">    _STL_INTERNAL_CHECK(_Bottom &gt; <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">using</span> _Diff      = _Iter_diff_t&lt;_RanIt&gt;;</span><br><span class="line">    <span class="type">const</span> _Diff _Top = _Hole;</span><br><span class="line">    _Diff _Idx       = _Hole;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 官方注释 Check whether _Idx can have a child before calculating that child&#x27;s index, since calculating the child&#x27;s index can trigger integer overflows</span></span><br><span class="line">	<span class="comment">// 检查 idx 节点是否能有子节点,因为 计算子节点 可能导致 整数溢出</span></span><br><span class="line">	<span class="comment">// 在 堆(完全二叉树) 中 有子节点的节点是前一半节点</span></span><br><span class="line">    <span class="type">const</span> _Diff _Max_sequence_non_leaf = (_Bottom - <span class="number">1</span>) &gt;&gt; <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 当 idx 节点有子节点,即不为叶子节点时</span></span><br><span class="line">    <span class="keyword">while</span> (_Idx &lt; _Max_sequence_non_leaf) </span><br><span class="line">	&#123; </span><br><span class="line">		<span class="comment">// 官方注释 : move _Hole down to larger child, 把 hole 设置为 较大的子节点的位置</span></span><br><span class="line">        _Idx = <span class="number">2</span> * _Idx + <span class="number">2</span>;</span><br><span class="line">		<span class="keyword">if</span> (_DEBUG_LT_PRED(_Pred, *(_First + _Idx), *(_First + (_Idx - <span class="number">1</span>)))) </span><br><span class="line">		&#123;</span><br><span class="line">            --_Idx;</span><br><span class="line">        &#125;</span><br><span class="line">        *(_First + _Hole) = _STD <span class="built_in">move</span>(*(_First + _Idx));</span><br><span class="line">        _Hole             = _Idx;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 官方注释 : only child at bottom, move _Hole down to it</span></span><br><span class="line">	<span class="comment">// 只有 左子节点 的情况的考虑</span></span><br><span class="line">    <span class="keyword">if</span> (_Idx == _Max_sequence_non_leaf &amp;&amp; _Bottom % <span class="number">2</span> == <span class="number">0</span>) </span><br><span class="line">    &#123; </span><br><span class="line">        *(_First + _Hole) = _STD <span class="built_in">move</span>(*(_First + (_Bottom - <span class="number">1</span>)));</span><br><span class="line">        _Hole             = _Bottom - <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">// 找到了合适的 hole , 把值 push 进去就可以了</span></span><br><span class="line">    _Push_heap_by_index(_First, _Hole, _Top, _STD forward&lt;_Ty&gt;(_Val), _Pred);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<hr>
<p><strong><code>sort_heap</code></strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">_RanIt</span>&gt;</span><br><span class="line"><span class="function">_CONSTEXPR20 <span class="type">void</span> <span class="title">sort_heap</span><span class="params">(_RanIt _First, _RanIt _Last)</span> </span></span><br><span class="line"><span class="function"></span>&#123; 	<span class="comment">// order heap by repeatedly popping</span></span><br><span class="line">    <span class="function">_STD <span class="title">sort_heap</span><span class="params">(_First, _Last, less&lt;&gt;&#123;&#125;)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">_RanIt</span>, <span class="keyword">class</span> <span class="title class_">_Pr</span>&gt;</span><br><span class="line"><span class="function">_CONSTEXPR20 <span class="type">void</span> <span class="title">sort_heap</span><span class="params">(_RanIt _First, _RanIt _Last, _Pr _Pred)</span> </span></span><br><span class="line"><span class="function"></span>&#123; 	<span class="comment">// order heap by repeatedly popping</span></span><br><span class="line">    _Adl_verify_range(_First, _Last);</span><br><span class="line">    <span class="type">const</span> <span class="keyword">auto</span> _UFirst = _Get_unwrapped(_First);</span><br><span class="line">    <span class="type">const</span> <span class="keyword">auto</span> _ULast  = _Get_unwrapped(_Last);</span><br><span class="line"><span class="meta">#<span class="keyword">if</span> _ITERATOR_DEBUG_LEVEL == 2</span></span><br><span class="line">    <span class="type">const</span> <span class="keyword">auto</span> _Counterexample = _Is_heap_until_unchecked(_UFirst, _ULast, _Pass_fn(_Pred));</span><br><span class="line">    <span class="keyword">if</span> (_Counterexample != _ULast) &#123;</span><br><span class="line">        _STL_REPORT_ERROR(<span class="string">&quot;invalid heap in sort_heap()&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span> <span class="comment">// _ITERATOR_DEBUG_LEVEL == 2</span></span></span><br><span class="line">    _Sort_heap_unchecked(_UFirst, _ULast, _Pass_fn(_Pred));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">_RanIt</span>, <span class="keyword">class</span> <span class="title class_">_Pr</span>&gt;</span><br><span class="line">_CONSTEXPR20 <span class="type">void</span> _Sort_heap_unchecked(_RanIt _First, _RanIt _Last, _Pr _Pred) &#123;</span><br><span class="line">    <span class="comment">// 官方注释 ： order heap by repeatedly popping</span></span><br><span class="line">    <span class="comment">// 通过反复 pop 来实现 堆排序</span></span><br><span class="line">    <span class="keyword">for</span> (; _Last - _First &gt;= <span class="number">2</span>; --_Last) </span><br><span class="line">    &#123;</span><br><span class="line">        _Pop_heap_unchecked(_First, _Last, _Pred);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<p><strong><code>make_heap</code></strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">_RanIt</span>&gt;</span><br><span class="line"><span class="function">_CONSTEXPR20 <span class="type">void</span> <span class="title">make_heap</span><span class="params">(_RanIt _First, _RanIt _Last)</span> </span></span><br><span class="line"><span class="function"></span>&#123; 	<span class="comment">// make [_First, _Last) into a heap</span></span><br><span class="line">    <span class="function">_STD <span class="title">make_heap</span><span class="params">(_First, _Last, less&lt;&gt;&#123;&#125;)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">_RanIt</span>, <span class="keyword">class</span> <span class="title class_">_Pr</span>&gt;</span><br><span class="line"><span class="function">_CONSTEXPR20 <span class="type">void</span> <span class="title">make_heap</span><span class="params">(_RanIt _First, _RanIt _Last, _Pr _Pred)</span> </span></span><br><span class="line"><span class="function"></span>&#123; 	<span class="comment">// make [_First, _Last) into a heap</span></span><br><span class="line">    _Adl_verify_range(_First, _Last);</span><br><span class="line">    _Make_heap_unchecked(_Get_unwrapped(_First), _Get_unwrapped(_Last), _Pass_fn(_Pred));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">_RanIt</span>, <span class="keyword">class</span> <span class="title class_">_Pr</span>&gt;</span><br><span class="line">_CONSTEXPR20 <span class="type">void</span> _Make_heap_unchecked(_RanIt _First, _RanIt _Last, _Pr _Pred) </span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// make [_First, _Last) into a heap</span></span><br><span class="line">    <span class="keyword">using</span> _Diff   = _Iter_diff_t&lt;_RanIt&gt;;</span><br><span class="line">    _Diff _Bottom = _Last - _First;</span><br><span class="line">    <span class="keyword">for</span> (_Diff _Hole = _Bottom &gt;&gt; <span class="number">1</span>; _Hole &gt; <span class="number">0</span>;) </span><br><span class="line">    &#123;	<span class="comment">// shift for codegen</span></span><br><span class="line">        <span class="comment">// reheap top half, bottom to top</span></span><br><span class="line">        <span class="comment">// 官方注释 ： 从 第一个需要调整的子树(即前半节点 逆序)开始,将其头结点下沉,即POP</span></span><br><span class="line">        --_Hole;</span><br><span class="line">        _Iter_value_t&lt;_RanIt&gt; _Val = _STD <span class="built_in">move</span>(*(_First + _Hole));</span><br><span class="line">        _Pop_heap_hole_by_index(_First, _Hole, _Bottom, _STD <span class="built_in">move</span>(_Val), _Pred);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h1 id="priority-queue"><a href="#priority-queue" class="headerlink" title="priority_queue"></a>priority_queue</h1><h2 id="priority-queue-类源码"><a href="#priority-queue-类源码" class="headerlink" title="priority_queue 类源码"></a>priority_queue 类源码</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 由 container = vector 有 优先队列的底层内存组织是 数组/完全二叉树/堆</span></span><br><span class="line"><span class="comment">// pr = less&lt;&gt;.. 优先队列默认按照 小的优先级高 的比较器组织, 即堆将是一个小根堆</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">_Ty</span>, <span class="keyword">class</span> <span class="title class_">_Container</span> = vector&lt;_Ty&gt;, <span class="keyword">class</span> _Pr = less&lt;<span class="keyword">typename</span> _Container::value_type&gt;&gt;</span><br><span class="line"><span class="keyword">class</span> priority_queue </span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="comment">// 型别定义</span></span><br><span class="line">    <span class="keyword">using</span> value_type      = <span class="keyword">typename</span> _Container::value_type;</span><br><span class="line">    <span class="keyword">using</span> reference       = <span class="keyword">typename</span> _Container::reference;</span><br><span class="line">    <span class="keyword">using</span> const_reference = <span class="keyword">typename</span> _Container::const_reference;</span><br><span class="line">    <span class="keyword">using</span> size_type       = <span class="keyword">typename</span> _Container::size_type;</span><br><span class="line">    <span class="keyword">using</span> container_type  = _Container;</span><br><span class="line">    <span class="keyword">using</span> value_compare   = _Pr;</span><br><span class="line"></span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">	<span class="comment">// 成员变量 包括一个 container 和 一个 比较器</span></span><br><span class="line">	<span class="comment">// 这里可以看出 优先队列 是基于 容器 实现的, 是一个 适配器</span></span><br><span class="line">    _Container c&#123;&#125;;</span><br><span class="line">    _Pr comp&#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="comment">// 各类构造函数 这里只保留了一个</span></span><br><span class="line">	<span class="comment">// 可以看出 优先队列的构造 实际就是 构造堆</span></span><br><span class="line">    <span class="built_in">priority_queue</span>(<span class="type">const</span> _Pr&amp; _Pred, <span class="type">const</span> _Container&amp; _Cont) : <span class="built_in">c</span>(_Cont), <span class="built_in">comp</span>(_Pred) </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="function">_STD <span class="title">make_heap</span><span class="params">(c.begin(), c.end(), comp)</span></span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 各种操作函数</span></span><br><span class="line">	<span class="comment">/// empty</span></span><br><span class="line">    <span class="function">_NODISCARD <span class="type">bool</span> <span class="title">empty</span><span class="params">()</span> <span class="type">const</span> <span class="title">noexcept</span><span class="params">(<span class="keyword">noexcept</span>(c.empty()))</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> c.<span class="built_in">empty</span>();</span><br><span class="line">    &#125;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">/// size</span></span><br><span class="line">    <span class="function">_NODISCARD size_type <span class="title">size</span><span class="params">()</span> <span class="type">const</span> <span class="title">noexcept</span><span class="params">(<span class="keyword">noexcept</span>(c.size()))</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> c.<span class="built_in">size</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/// top = vec.front</span></span><br><span class="line">    <span class="function">_NODISCARD const_reference <span class="title">top</span><span class="params">()</span> <span class="type">const</span> <span class="title">noexcept</span><span class="params">(<span class="keyword">noexcept</span>(c.front()))</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> c.<span class="built_in">front</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/// push = vec.push_back + push_heap(vec.begin , vec.end , comp)</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">push</span><span class="params">(<span class="type">const</span> value_type&amp; _Val)</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        c.<span class="built_in">push_back</span>(_Val);</span><br><span class="line">        <span class="function">_STD <span class="title">push_heap</span><span class="params">(c.begin(), c.end(), comp)</span></span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">push</span><span class="params">(value_type&amp;&amp; _Val)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        c.<span class="built_in">push_back</span>(_STD <span class="built_in">move</span>(_Val));</span><br><span class="line">        <span class="function">_STD <span class="title">push_heap</span><span class="params">(c.begin(), c.end(), comp)</span></span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/// emplace</span></span><br><span class="line">    <span class="keyword">template</span> &lt;<span class="keyword">class</span>... _Valty&gt;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">emplace</span><span class="params">(_Valty&amp;&amp;... _Val)</span> </span>&#123;</span><br><span class="line">        c.<span class="built_in">emplace_back</span>(_STD forward&lt;_Valty&gt;(_Val)...);</span><br><span class="line">        <span class="function">_STD <span class="title">push_heap</span><span class="params">(c.begin(), c.end(), comp)</span></span>;</span><br><span class="line">    &#125;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">/// pop = pop_heap + vec.pop_back</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">pop</span><span class="params">()</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="function">_STD <span class="title">pop_heap</span><span class="params">(c.begin(), c.end(), comp)</span></span>;</span><br><span class="line">        c.<span class="built_in">pop_back</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/// emplace</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">swap</span><span class="params">(priority_queue&amp; _Right)</span> <span class="title">noexcept</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">        _Is_nothrow_swappable&lt;_Container&gt;::value&amp;&amp; _Is_nothrow_swappable&lt;_Pr&gt;::value)</span></span></span><br><span class="line"><span class="function">        </span>&#123;</span><br><span class="line">        _Swap_adl(c, _Right.c);</span><br><span class="line">        _Swap_adl(comp, _Right.comp);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<hr>
<h1 id="rb-tree"><a href="#rb-tree" class="headerlink" title="rb_tree"></a>rb_tree</h1><h2 id="Tree-node-树结点数据结构-源码"><a href="#Tree-node-树结点数据结构-源码" class="headerlink" title="Tree_node 树结点数据结构 源码"></a>Tree_node 树结点数据结构 源码</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">_Value_type</span>, <span class="keyword">class</span> <span class="title class_">_Voidptr</span>&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">_Tree_node</span> </span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">using</span> _Nodeptr   = _Rebind_pointer_t&lt;_Voidptr, _Tree_node&gt;;</span><br><span class="line">    <span class="keyword">using</span> value_type = _Value_type;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 数据成员</span></span><br><span class="line">	<span class="comment">// left subtree, or smallest element if head</span></span><br><span class="line">	<span class="comment">// 左兄弟结点 如果为头结点的话 最小的的元素结点-最左结点</span></span><br><span class="line">    _Nodeptr _Left; </span><br><span class="line">    <span class="comment">// parent, or root of tree if head</span></span><br><span class="line">    <span class="comment">// 父结点 如果为头结点的话 树根结点</span></span><br><span class="line">    _Nodeptr _Parent; </span><br><span class="line">	<span class="comment">// right subtree, or largest element if head</span></span><br><span class="line">    <span class="comment">// 右兄弟结点 如果为头结点的话 最大的元素结点-最右结点</span></span><br><span class="line">    _Nodeptr _Right;</span><br><span class="line">    <span class="comment">// _Red or _Black, _Black if head</span></span><br><span class="line">    <span class="comment">// 结点颜色 如果为头结点的话 必为黑色</span></span><br><span class="line">    <span class="type">char</span> _Color;</span><br><span class="line">    <span class="comment">// true only if head (also nil) node; TRANSITION, should be bool</span></span><br><span class="line">    <span class="comment">// </span></span><br><span class="line">    <span class="type">char</span> _Isnil; </span><br><span class="line">    <span class="comment">// the stored value, unused if head</span></span><br><span class="line">    <span class="comment">// 存储的元素 如果为头结点的话 UNUSED</span></span><br><span class="line">    value_type _Myval;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">// colors for link to parent</span></span><br><span class="line">    <span class="keyword">enum</span> <span class="title class_">_Redbl</span> </span><br><span class="line">    &#123; </span><br><span class="line">        _Red,</span><br><span class="line">        _Black</span><br><span class="line">    &#125;;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">// 一些相关的函数</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<hr>
<h2 id="rb-tree-类源码"><a href="#rb-tree-类源码" class="headerlink" title="rb_tree 类源码"></a>rb_tree 类源码</h2><p><strong>成员变量</strong><br><em>不太好找…..</em></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 通过这个函数结合DEBUG时监视变量可以大概推测</span></span><br><span class="line"><span class="comment">// 成员变量包括 虚拟头结点 _Head 和 树大小 size</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">clear</span><span class="params">()</span> <span class="keyword">noexcept</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">        <span class="type">const</span> <span class="keyword">auto</span> _Scary = _Get_scary();</span><br><span class="line">        _Scary-&gt;_Orphan_ptr(<span class="literal">nullptr</span>);</span><br><span class="line">        <span class="keyword">auto</span> _Head = _Scary-&gt;_Myhead;</span><br><span class="line">        _Scary-&gt;_Erase_tree(_Getal(), _Head-&gt;_Parent);</span><br><span class="line">        _Head-&gt;_Parent  = _Head;</span><br><span class="line">        _Head-&gt;_Left    = _Head;</span><br><span class="line">        _Head-&gt;_Right   = _Head;</span><br><span class="line">        _Scary-&gt;_Mysize = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>类源码</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br><span class="line">308</span><br><span class="line">309</span><br><span class="line">310</span><br><span class="line">311</span><br><span class="line">312</span><br><span class="line">313</span><br><span class="line">314</span><br><span class="line">315</span><br><span class="line">316</span><br><span class="line">317</span><br><span class="line">318</span><br><span class="line">319</span><br><span class="line">320</span><br><span class="line">321</span><br><span class="line">322</span><br><span class="line">323</span><br><span class="line">324</span><br><span class="line">325</span><br><span class="line">326</span><br><span class="line">327</span><br><span class="line">328</span><br><span class="line">329</span><br><span class="line">330</span><br><span class="line">331</span><br><span class="line">332</span><br><span class="line">333</span><br><span class="line">334</span><br><span class="line">335</span><br><span class="line">336</span><br><span class="line">337</span><br><span class="line">338</span><br><span class="line">339</span><br><span class="line">340</span><br><span class="line">341</span><br><span class="line">342</span><br><span class="line">343</span><br><span class="line">344</span><br><span class="line">345</span><br><span class="line">346</span><br><span class="line">347</span><br><span class="line">348</span><br><span class="line">349</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">_Traits</span>&gt;</span><br><span class="line"><span class="comment">// 官方注释 ： ordered red-black tree for map/multimap/set/multiset</span></span><br><span class="line"><span class="comment">// 可以看出 排序的红黑树 是 map/multimap/set/multiset 的底层实现</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">_Tree</span> </span><br><span class="line">&#123; </span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">	<span class="comment">// scary_val 是 tree_val 所以上面关于TREE的数据成员的推测有一定道理</span></span><br><span class="line">    <span class="keyword">using</span> _Scary_val = _Tree_val&lt;<span class="type">conditional_t</span>&lt;_Is_simple_alloc_v&lt;_Alnode&gt;, _Tree_simple_types&lt;value_type&gt;,</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="comment">// 从这里可以找到 迭代器定义</span></span><br><span class="line">    <span class="keyword">using</span> iterator =</span><br><span class="line">        <span class="type">conditional_t</span>&lt;is_same_v&lt;key_type, value_type&gt;, _Tree_const_iterator&lt;_Scary_val&gt;, _Tree_iterator&lt;_Scary_val&gt;&gt;;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// ...构造与析构函数</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">	<span class="comment">// emplace 函数</span></span><br><span class="line">    <span class="keyword">template</span> &lt;<span class="keyword">class</span>... _Valtys&gt;</span><br><span class="line">    pair&lt;_Nodeptr, <span class="type">bool</span>&gt; _Emplace(_Valtys&amp;&amp;... _Vals) </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">using</span> _In_place_key_extractor = <span class="keyword">typename</span> _Traits::<span class="keyword">template</span> _In_place_key_extractor&lt;_Remove_cvref_t&lt;_Valtys&gt;...&gt;;</span><br><span class="line">        <span class="type">const</span> <span class="keyword">auto</span> _Scary = _Get_scary();</span><br><span class="line">        _Tree_find_result&lt;_Nodeptr&gt; _Loc;</span><br><span class="line">        _Nodeptr _Inserted;</span><br><span class="line">        <span class="function"><span class="keyword">if</span> <span class="title">constexpr</span> <span class="params">(!_Multi &amp;&amp; _In_place_key_extractor::_Extractable)</span></span></span><br><span class="line"><span class="function">        </span>&#123;</span><br><span class="line">            <span class="type">const</span> <span class="keyword">auto</span>&amp; _Keyval = _In_place_key_extractor::_Extract(_Vals...);</span><br><span class="line">            <span class="comment">// 通过 find_lower_bound 来找到插入点</span></span><br><span class="line">            _Loc = _Find_lower_bound(_Keyval);</span><br><span class="line">            <span class="keyword">if</span> (_Lower_bound_duplicate(_Loc._Bound, _Keyval))</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">return</span> &#123;_Loc._Bound, <span class="literal">false</span>&#125;;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            _Check_grow_by_1();</span><br><span class="line">            _Inserted = _Tree_temp_node&lt;_Alnode&gt;(_Getal(), _Scary-&gt;_Myhead, _STD forward&lt;_Valtys&gt;(_Vals)...)._Release();</span><br><span class="line">            <span class="comment">// nothrow hereafter</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            _Tree_temp_node&lt;_Alnode&gt; _Newnode(_Getal(), _Scary-&gt;_Myhead, _STD forward&lt;_Valtys&gt;(_Vals)...);</span><br><span class="line">            <span class="type">const</span> <span class="keyword">auto</span>&amp; _Keyval = _Traits::_Kfn(_Newnode._Ptr-&gt;_Myval);</span><br><span class="line">            <span class="comment">// 对 multi 属性做判断</span></span><br><span class="line">            <span class="comment">// multi -- 插入点为 _Find_upper_bound(_Keyval) -- 所以在 multi 的容器中,相同KEY值的元素按先后顺序排列</span></span><br><span class="line">            <span class="comment">// not -- _Find_lower_bound(_Keyval)</span></span><br><span class="line">            <span class="function"><span class="keyword">if</span> <span class="title">constexpr</span> <span class="params">(_Multi)</span></span></span><br><span class="line"><span class="function">            </span>&#123; <span class="comment">// duplicate check if unique</span></span><br><span class="line">                _Loc = _Find_upper_bound(_Keyval);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                _Loc = _Find_lower_bound(_Keyval);</span><br><span class="line">                <span class="keyword">if</span> (_Lower_bound_duplicate(_Loc._Bound, _Keyval)) &#123;</span><br><span class="line">                    <span class="keyword">return</span> &#123;_Loc._Bound, <span class="literal">false</span>&#125;;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            _Check_grow_by_1();</span><br><span class="line">            <span class="comment">// nothrow hereafter</span></span><br><span class="line">            _Inserted = _Newnode._Release();</span><br><span class="line">        &#125;</span><br><span class="line">		<span class="comment">// 最后调用 insert_node 函数插入</span></span><br><span class="line">        <span class="keyword">return</span> &#123;_Scary-&gt;_Insert_node(_Loc._Location, _Inserted), <span class="literal">true</span>&#125;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	<span class="comment">// begin 函数 </span></span><br><span class="line">	<span class="comment">// 返回值为 head-&gt;left</span></span><br><span class="line">	<span class="comment">// ? 返回查看treenode定义 当node为头结点的时候left就是最小元素的结点 也就是说 begin指向的是最小的元素</span></span><br><span class="line">    <span class="function">_NODISCARD iterator <span class="title">begin</span><span class="params">()</span> <span class="keyword">noexcept</span> </span>&#123;</span><br><span class="line">        <span class="type">const</span> <span class="keyword">auto</span> _Scary = _Get_scary();</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">iterator</span>(_Scary-&gt;_Myhead-&gt;_Left, _Scary);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// end 函数</span></span><br><span class="line">	<span class="comment">// 返回值为 myhead</span></span><br><span class="line">	<span class="comment">// ? end的指向是最后一个元素的后一位,参考treenode迭代器定义</span></span><br><span class="line">    <span class="function">_NODISCARD iterator <span class="title">end</span><span class="params">()</span> <span class="keyword">noexcept</span> </span>&#123;</span><br><span class="line">        <span class="type">const</span> <span class="keyword">auto</span> _Scary = _Get_scary();</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">iterator</span>(_Scary-&gt;_Myhead, _Scary);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// rbegin and rend</span></span><br><span class="line">    <span class="function">_NODISCARD reverse_iterator <span class="title">rbegin</span><span class="params">()</span> <span class="keyword">noexcept</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">reverse_iterator</span>(<span class="built_in">end</span>());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">_NODISCARD reverse_iterator <span class="title">rend</span><span class="params">()</span> <span class="keyword">noexcept</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">reverse_iterator</span>(<span class="built_in">begin</span>());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// cbegin and cend</span></span><br><span class="line">    <span class="function">_NODISCARD const_iterator <span class="title">cbegin</span><span class="params">()</span> <span class="type">const</span> <span class="keyword">noexcept</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">begin</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">_NODISCARD const_iterator <span class="title">cend</span><span class="params">()</span> <span class="type">const</span> <span class="keyword">noexcept</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">end</span>();</span><br><span class="line">    &#125;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">// crbegin and crend</span></span><br><span class="line">    <span class="function">_NODISCARD const_reverse_iterator <span class="title">crbegin</span><span class="params">()</span> <span class="type">const</span> <span class="keyword">noexcept</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">rbegin</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">_NODISCARD const_reverse_iterator <span class="title">crend</span><span class="params">()</span> <span class="type">const</span> <span class="keyword">noexcept</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">rend</span>();</span><br><span class="line">    &#125;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">// size 函数</span></span><br><span class="line">    <span class="function">_NODISCARD size_type <span class="title">size</span><span class="params">()</span> <span class="type">const</span> <span class="keyword">noexcept</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> _Get_scary()-&gt;_Mysize;</span><br><span class="line">    &#125;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">// empty 函数</span></span><br><span class="line">    <span class="function">_NODISCARD <span class="type">bool</span> <span class="title">empty</span><span class="params">()</span> <span class="type">const</span> <span class="keyword">noexcept</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> _Get_scary()-&gt;_Mysize == <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// get_allocator 可以获取到内存分配器?</span></span><br><span class="line">    <span class="function">_NODISCARD allocator_type <span class="title">get_allocator</span><span class="params">()</span> <span class="type">const</span> <span class="keyword">noexcept</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">static_cast</span>&lt;allocator_type&gt;(_Getal());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 键值比较函数</span></span><br><span class="line">    <span class="function">_NODISCARD key_compare <span class="title">key_comp</span><span class="params">()</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> _Getcomp();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">_NODISCARD value_compare <span class="title">value_comp</span><span class="params">()</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">value_compare</span>(<span class="built_in">key_comp</span>());</span><br><span class="line">    &#125;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">// insert 函数</span></span><br><span class="line">	<span class="comment">// 这里可以清晰的看到返回值为 pair&lt;iterator, bool&gt;</span></span><br><span class="line">    <span class="keyword">template</span> &lt;<span class="type">bool</span> _Multi2 = _Multi, <span class="type">enable_if_t</span>&lt;!_Multi2, <span class="type">int</span>&gt; = <span class="number">0</span>&gt;</span><br><span class="line">    pair&lt;iterator, <span class="type">bool</span>&gt; <span class="built_in">insert</span>(<span class="type">const</span> value_type&amp; _Val)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">const</span> <span class="keyword">auto</span> _Result = _Emplace(_Val);</span><br><span class="line">        <span class="keyword">return</span> &#123;<span class="built_in">iterator</span>(_Result.first, _Get_scary()), _Result.second&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">	<span class="comment">// clear 函数 由此可以观察 scary 的变量</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">clear</span><span class="params">()</span> <span class="keyword">noexcept</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="type">const</span> <span class="keyword">auto</span> _Scary = _Get_scary();</span><br><span class="line">        _Scary-&gt;_Orphan_ptr(<span class="literal">nullptr</span>);</span><br><span class="line">        <span class="keyword">auto</span> _Head = _Scary-&gt;_Myhead;</span><br><span class="line">        _Scary-&gt;_Erase_tree(_Getal(), _Head-&gt;_Parent);</span><br><span class="line">        _Head-&gt;_Parent  = _Head;</span><br><span class="line">        _Head-&gt;_Left    = _Head;</span><br><span class="line">        _Head-&gt;_Right   = _Head;</span><br><span class="line">        _Scary-&gt;_Mysize = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	<span class="comment">// find 函数</span></span><br><span class="line">	<span class="comment">// 可以看到是通过 find_lower_bound 来找的</span></span><br><span class="line">	<span class="comment">// 没找到返回 end</span></span><br><span class="line">    <span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">_Other</span>&gt;</span><br><span class="line">    _NODISCARD _Nodeptr _Find(<span class="type">const</span> _Other&amp; _Keyval) <span class="type">const</span> </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">const</span> _Tree_find_result&lt;_Nodeptr&gt; _Loc = _Find_lower_bound(_Keyval);</span><br><span class="line">        <span class="keyword">if</span> (_Lower_bound_duplicate(_Loc._Bound, _Keyval))</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> _Loc._Bound;</span><br><span class="line">        &#125;</span><br><span class="line">		<span class="comment">// 没找到 返回 end</span></span><br><span class="line">        <span class="keyword">return</span> _Get_scary()-&gt;_Myhead;</span><br><span class="line">    &#125;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">// contains 函数</span></span><br><span class="line">    <span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">_Other</span>, <span class="keyword">class</span> <span class="title class_">_Mycomp</span> = key_compare, <span class="keyword">class</span> = <span class="keyword">typename</span> _Mycomp::is_transparent&gt;</span><br><span class="line">    _NODISCARD <span class="type">bool</span> <span class="built_in">contains</span>(<span class="type">const</span> _Other&amp; _Keyval) <span class="type">const</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> _Lower_bound_duplicate(_Find_lower_bound(_Keyval)._Bound, _Keyval);</span><br><span class="line">    &#125;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span> <span class="comment">// _HAS_CXX20</span></span></span><br><span class="line"></span><br><span class="line">    <span class="function">_NODISCARD size_type <span class="title">count</span><span class="params">(<span class="type">const</span> key_type&amp; _Keyval)</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">        <span class="function"><span class="keyword">if</span> <span class="title">constexpr</span> <span class="params">(_Multi)</span> </span>&#123;</span><br><span class="line">            <span class="type">const</span> <span class="keyword">auto</span> _Ans = _Eqrange(_Keyval);</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">static_cast</span>&lt;size_type&gt;(_STD <span class="built_in">distance</span>(</span><br><span class="line">                _Unchecked_const_iterator(_Ans.first, <span class="literal">nullptr</span>), _Unchecked_const_iterator(_Ans.second, <span class="literal">nullptr</span>)));</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> _Lower_bound_duplicate(_Find_lower_bound(_Keyval)._Bound, _Keyval);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">_Other</span>, <span class="keyword">class</span> <span class="title class_">_Mycomp</span> = key_compare, <span class="keyword">class</span> = <span class="keyword">typename</span> _Mycomp::is_transparent&gt;</span><br><span class="line">    _NODISCARD size_type <span class="built_in">count</span>(<span class="type">const</span> _Other&amp; _Keyval) <span class="type">const</span> &#123;</span><br><span class="line">        <span class="type">const</span> <span class="keyword">auto</span> _Ans = _Eqrange(_Keyval);</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">static_cast</span>&lt;size_type&gt;(_STD <span class="built_in">distance</span>(</span><br><span class="line">            _Unchecked_const_iterator(_Ans.first, <span class="literal">nullptr</span>), _Unchecked_const_iterator(_Ans.second, <span class="literal">nullptr</span>)));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/// 大量的函数做了二次封装</span></span><br><span class="line">	<span class="comment">// lower_bound函数</span></span><br><span class="line">    <span class="function">_NODISCARD iterator <span class="title">lower_bound</span><span class="params">(<span class="type">const</span> key_type&amp; _Keyval)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">iterator</span>(_Find_lower_bound(_Keyval)._Bound, _Get_scary());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// upper_bound</span></span><br><span class="line">    <span class="function">_NODISCARD iterator <span class="title">upper_bound</span><span class="params">(<span class="type">const</span> key_type&amp; _Keyval)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">iterator</span>(_Find_upper_bound(_Keyval)._Bound, _Get_scary());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// equal_range</span></span><br><span class="line">    <span class="function">_NODISCARD pair&lt;iterator, iterator&gt; <span class="title">equal_range</span><span class="params">(<span class="type">const</span> key_type&amp; _Keyval)</span> </span>&#123;</span><br><span class="line">        <span class="type">const</span> <span class="keyword">auto</span> _Result = _Eqrange(_Keyval);</span><br><span class="line">        <span class="type">const</span> <span class="keyword">auto</span> _Scary  = _Get_scary();</span><br><span class="line">        <span class="keyword">return</span> &#123;<span class="built_in">iterator</span>(_Result.first, _Scary), <span class="built_in">iterator</span>(_Result.second, _Scary)&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// swap</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">swap</span><span class="params">(_Tree&amp; _Right)</span> <span class="title">noexcept</span><span class="params">(_Is_nothrow_swappable&lt;key_compare&gt;::value)</span> <span class="comment">/* strengthened */</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span> != _STD <span class="built_in">addressof</span>(_Right)) &#123;</span><br><span class="line">            _Pocs(_Getal(), _Right._Getal());</span><br><span class="line">            _Swap_val_excluding_comp(_Right);</span><br><span class="line">            _Swap_adl(_Getcomp(), _Right._Getcomp());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">////</span></span><br><span class="line"><span class="comment">// 从这里开始 是 前面的做了二次封装的功能函数的具体实现 </span></span><br><span class="line"><span class="comment">////</span></span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">    <span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">_Keyty</span>&gt;</span><br><span class="line">    _Tree_find_hint_result&lt;_Nodeptr&gt; _Find_hint(<span class="type">const</span> _Nodeptr _Hint, <span class="type">const</span> _Keyty&amp; _Keyval) <span class="type">const</span> </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">const</span> <span class="keyword">auto</span>&amp; _Comp = _Getcomp();</span><br><span class="line">        <span class="type">const</span> <span class="keyword">auto</span> _Head  = _Get_scary()-&gt;_Myhead;</span><br><span class="line">        <span class="function"><span class="keyword">if</span> <span class="title">constexpr</span> <span class="params">(_Multi)</span> </span></span><br><span class="line"><span class="function">        </span>&#123;</span><br><span class="line">        <span class="comment">// 官方注释 insert even if duplicate</span></span><br><span class="line">        <span class="comment">// 可见 对于容器是否允许重复元素 RBTREE 是根据 Multi 变量来感知的</span></span><br><span class="line">            <span class="keyword">if</span> (_Hint-&gt;_Isnil) &#123;</span><br><span class="line">                <span class="comment">// insert at end if greater than or equal to last element</span></span><br><span class="line">                <span class="keyword">if</span> (_Head-&gt;_Parent-&gt;_Isnil || !_DEBUG_LT_PRED(_Comp, _Keyval, _Traits::_Kfn(_Head-&gt;_Right-&gt;_Myval))) &#123;</span><br><span class="line">                    <span class="keyword">return</span> &#123;&#123;_Head-&gt;_Right, _Tree_child::_Right&#125;, <span class="literal">false</span>&#125;;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="comment">// _Hint is end(); it must be closer to the end of equivalents</span></span><br><span class="line">                <span class="keyword">return</span> &#123;_Find_upper_bound(_Keyval)._Location, <span class="literal">false</span>&#125;;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (_Hint == _Head-&gt;_Left) &#123;</span><br><span class="line">                <span class="comment">// insert at beginning if less than or equal to first element</span></span><br><span class="line">                <span class="keyword">if</span> (!_DEBUG_LT_PRED(_Comp, _Traits::_Kfn(_Hint-&gt;_Myval), _Keyval)) &#123;</span><br><span class="line">                    <span class="keyword">return</span> &#123;&#123;_Hint, _Tree_child::_Left&#125;, <span class="literal">false</span>&#125;;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="comment">// _Hint is begin(); it must be closer to the beginning of equivalents</span></span><br><span class="line">                <span class="keyword">return</span> &#123;_Find_lower_bound(_Keyval)._Location, <span class="literal">false</span>&#125;;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (!_DEBUG_LT_PRED(_Comp, _Traits::_Kfn(_Hint-&gt;_Myval), _Keyval)) &#123;</span><br><span class="line">                <span class="comment">// _Val &lt;= *_Hint</span></span><br><span class="line">                <span class="type">const</span> <span class="keyword">auto</span> _Prev = (--(_Unchecked_const_iterator(_Hint, <span class="literal">nullptr</span>)))._Ptr;</span><br><span class="line">                <span class="keyword">if</span> (!_DEBUG_LT_PRED(_Comp, _Keyval, _Traits::_Kfn(_Prev-&gt;_Myval))) &#123;</span><br><span class="line">                    <span class="comment">// _Val &lt;= *_Hint and _Val &gt;= *prev(_Hint); insert here</span></span><br><span class="line">                    <span class="keyword">if</span> (_Prev-&gt;_Right-&gt;_Isnil) &#123;</span><br><span class="line">                        <span class="keyword">return</span> &#123;&#123;_Prev, _Tree_child::_Right&#125;, <span class="literal">false</span>&#125;;</span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        <span class="keyword">return</span> &#123;&#123;_Hint, _Tree_child::_Left&#125;, <span class="literal">false</span>&#125;;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="comment">// _Val goes before *_Hint; _Hint must be closer to the end of equivalents</span></span><br><span class="line">                <span class="keyword">return</span> &#123;_Find_upper_bound(_Keyval)._Location, <span class="literal">false</span>&#125;;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// _Val goes after *_Hint; _Hint must be closer to the beginning of equivalents</span></span><br><span class="line">            <span class="keyword">return</span> &#123;_Find_lower_bound(_Keyval)._Location, <span class="literal">false</span>&#125;;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123; <span class="comment">// insert only if unique</span></span><br><span class="line">            <span class="keyword">if</span> (_Hint-&gt;_Isnil) &#123; <span class="comment">// insert at end if after last element</span></span><br><span class="line">                <span class="comment">// insert at end if greater than last element</span></span><br><span class="line">                <span class="keyword">if</span> (_Head-&gt;_Parent-&gt;_Isnil || _DEBUG_LT_PRED(_Comp, _Traits::_Kfn(_Head-&gt;_Right-&gt;_Myval), _Keyval)) &#123;</span><br><span class="line">                    <span class="keyword">return</span> &#123;&#123;_Head-&gt;_Right, _Tree_child::_Right&#125;, <span class="literal">false</span>&#125;;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (_Hint == _Head-&gt;_Left) &#123;</span><br><span class="line">                <span class="comment">// insert at beginning if less than first element</span></span><br><span class="line">                <span class="keyword">if</span> (_DEBUG_LT_PRED(_Comp, _Keyval, _Traits::_Kfn(_Hint-&gt;_Myval))) &#123;</span><br><span class="line">                    <span class="keyword">return</span> &#123;&#123;_Hint, _Tree_child::_Left&#125;, <span class="literal">false</span>&#125;;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (_DEBUG_LT_PRED(_Comp, _Keyval, _Traits::_Kfn(_Hint-&gt;_Myval))) &#123;</span><br><span class="line">                <span class="comment">// _Val &lt; *_Hint</span></span><br><span class="line">                <span class="type">const</span> <span class="keyword">auto</span> _Prev = (--(_Unchecked_const_iterator(_Hint, <span class="literal">nullptr</span>)))._Ptr;</span><br><span class="line">                <span class="keyword">if</span> (_DEBUG_LT_PRED(_Comp, _Traits::_Kfn(_Prev-&gt;_Myval), _Keyval)) &#123;</span><br><span class="line">                    <span class="comment">// _Val &lt; *_Hint and _Val &gt; *prev(_Hint); insert here</span></span><br><span class="line">                    <span class="keyword">if</span> (_Prev-&gt;_Right-&gt;_Isnil) &#123;</span><br><span class="line">                        <span class="keyword">return</span> &#123;&#123;_Prev, _Tree_child::_Right&#125;, <span class="literal">false</span>&#125;;</span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        <span class="keyword">return</span> &#123;&#123;_Hint, _Tree_child::_Left&#125;, <span class="literal">false</span>&#125;;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (_DEBUG_LT_PRED(_Comp, _Traits::_Kfn(_Hint-&gt;_Myval), _Keyval)) &#123;</span><br><span class="line">                <span class="comment">// _Val &gt; *_Hint</span></span><br><span class="line">                <span class="type">const</span> <span class="keyword">auto</span> _Next = (++(_Unchecked_const_iterator(_Hint, <span class="literal">nullptr</span>)))._Ptr;</span><br><span class="line">                <span class="keyword">if</span> (_Next-&gt;_Isnil || _DEBUG_LT_PRED(_Comp, _Keyval, _Traits::_Kfn(_Next-&gt;_Myval))) &#123;</span><br><span class="line">                    <span class="comment">// _Val &gt; *_Hint and _Val &lt; *next(_Hint); insert here</span></span><br><span class="line">                    <span class="keyword">if</span> (_Hint-&gt;_Right-&gt;_Isnil) &#123;</span><br><span class="line">                        <span class="keyword">return</span> &#123;&#123;_Hint, _Tree_child::_Right&#125;, <span class="literal">false</span>&#125;;</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                    <span class="keyword">return</span> &#123;&#123;_Next, _Tree_child::_Left&#125;, <span class="literal">false</span>&#125;;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// _Val is equivalent to *_Hint; don&#x27;t insert</span></span><br><span class="line">                <span class="keyword">return</span> &#123;&#123;_Hint, _Tree_child::_Right&#125;, <span class="literal">true</span>&#125;;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="type">const</span> <span class="keyword">auto</span> _Loc = _Find_lower_bound(_Keyval);</span><br><span class="line">            <span class="keyword">if</span> (_Lower_bound_duplicate(_Loc._Bound, _Keyval)) &#123;</span><br><span class="line">                <span class="keyword">return</span> &#123;&#123;_Loc._Bound, _Tree_child::_Unused&#125;, <span class="literal">true</span>&#125;;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">return</span> &#123;_Loc._Location, <span class="literal">false</span>&#125;;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    template &lt;class _Nodeptr&gt;</span></span><br><span class="line"><span class="comment">	struct _Tree_find_result </span></span><br><span class="line"><span class="comment">	&#123;</span></span><br><span class="line"><span class="comment">    	_Tree_id&lt;_Nodeptr&gt; _Location;</span></span><br><span class="line"><span class="comment">    	_Nodeptr _Bound;</span></span><br><span class="line"><span class="comment">	&#125;;</span></span><br><span class="line"><span class="comment">	template &lt;class _Nodeptr&gt;</span></span><br><span class="line"><span class="comment">	struct _Tree_id &#123;</span></span><br><span class="line"><span class="comment">    	_Nodeptr _Parent; // the leaf node under which a new node should be inserted</span></span><br><span class="line"><span class="comment">    	_Tree_child _Child;</span></span><br><span class="line"><span class="comment">	&#125;;</span></span><br><span class="line"><span class="comment">	enum class _Tree_child</span></span><br><span class="line"><span class="comment">	&#123;</span></span><br><span class="line"><span class="comment">    	_Right, // perf note: compare with _Right rather than _Left where possible for comparison with zero</span></span><br><span class="line"><span class="comment">    	_Left,</span></span><br><span class="line"><span class="comment">    	_Unused // indicates that tree child should never be used for insertion</span></span><br><span class="line"><span class="comment">	&#125;;</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">	<span class="comment">// find_upper_bound 寻找上边界 即 &gt;val 的第一个节点</span></span><br><span class="line">    <span class="comment">// 由上数据结构有 返回值_Tree_find_result&lt;_Nodeptr&gt; 包括 位置(是谁的子节点以及是左/右/NULL节点) 与 边界 </span></span><br><span class="line">    <span class="comment">// 结合 红黑树 的特性 这将是一个发生在树上的 二分定界问题</span></span><br><span class="line">    <span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">_Keyty</span>&gt;</span><br><span class="line">    _Tree_find_result&lt;_Nodeptr&gt; _Find_upper_bound(<span class="type">const</span> _Keyty&amp; _Keyval) <span class="type">const</span> </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">const</span> <span class="keyword">auto</span> _Scary = _Get_scary();</span><br><span class="line">        _Tree_find_result&lt;_Nodeptr&gt; _Result&#123;</span><br><span class="line">            &#123;_Scary-&gt;_Myhead-&gt;_Parent, _Tree_child::_Right&#125;,</span><br><span class="line">            _Scary-&gt;_Myhead&#125;;</span><br><span class="line">            _Nodeptr _Trynode = _Result._Location._Parent;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>画点图 有点难理解</p>
<ol>
<li>res.loc.parent &#x3D; myhead-&gt;parent  &#x3D; root ; res 的父节点是 root 节点</li>
<li>res.loc.childtype &#x3D; right; res 是 root 的右孩子节点</li>
<li>res.bound &#x3D; myhead; 当前边界是 myhead<pre class="mermaid">graph
myhead((myhead bound))
root((root trynode))
r((r res))
l((l))
myhead --> root
root --> l
root -->r</pre>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br></pre></td><td class="code"><pre><span class="line">        <span class="keyword">while</span> (!_Trynode-&gt;_Isnil) </span><br><span class="line">        &#123;</span><br><span class="line">            _Result._Location._Parent = _Trynode;</span><br><span class="line">            <span class="comment">// 如果 parent.val &gt; val , 那么 bound = parent , trynode = left</span></span><br><span class="line">            <span class="keyword">if</span> (_DEBUG_LT_PRED(_Getcomp(), _Keyval, _Traits::_Kfn(_Trynode-&gt;_Myval)))</span><br><span class="line">            &#123;</span><br><span class="line">                _Result._Location._Child = _Tree_child::_Left;</span><br><span class="line">                _Result._Bound           = _Trynode;</span><br><span class="line">                _Trynode                 = _Trynode-&gt;_Left;</span><br><span class="line">            &#125; </span><br><span class="line">            <span class="keyword">else</span> </span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">// 同理 如果 parent.val &lt;= val, 那么 bound 不变, trynode = right</span></span><br><span class="line">                _Result._Location._Child = _Tree_child::_Right;</span><br><span class="line">                _Trynode                 = _Trynode-&gt;_Right;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> _Result;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">_Keyty</span>&gt;</span><br><span class="line">    <span class="type">bool</span> _Lower_bound_duplicate(<span class="type">const</span> _Nodeptr _Bound, <span class="type">const</span> _Keyty&amp; _Keyval) <span class="type">const</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> !_Bound-&gt;_Isnil &amp;&amp; !_DEBUG_LT_PRED(_Getcomp(), _Keyval, _Traits::_Kfn(_Bound-&gt;_Myval));</span><br><span class="line">    &#125;</span><br><span class="line">	</span><br><span class="line">    <span class="comment">// find_lower_bound 寻找下边界</span></span><br><span class="line">    <span class="comment">// 基本同 find_upper_bound , 只是在 res.bound 的改变时机上有所不同</span></span><br><span class="line">    <span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">_Keyty</span>&gt;</span><br><span class="line">    _Tree_find_result&lt;_Nodeptr&gt; _Find_lower_bound(<span class="type">const</span> _Keyty&amp; _Keyval) <span class="type">const</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">const</span> <span class="keyword">auto</span> _Scary = _Get_scary();</span><br><span class="line">        _Tree_find_result&lt;_Nodeptr&gt; _Result&#123;</span><br><span class="line">            &#123;_Scary-&gt;_Myhead-&gt;_Parent, _Tree_child::_Right&#125;,</span><br><span class="line">            _Scary-&gt;_Myhead&#125;;</span><br><span class="line">        </span><br><span class="line">        _Nodeptr _Trynode = _Result._Location._Parent;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span> (!_Trynode-&gt;_Isnil) </span><br><span class="line">        &#123;</span><br><span class="line">            _Result._Location._Parent = _Trynode;</span><br><span class="line">            <span class="keyword">if</span> (_DEBUG_LT_PRED(_Getcomp(), _Traits::_Kfn(_Trynode-&gt;_Myval), _Keyval)) </span><br><span class="line">            &#123;</span><br><span class="line">                _Result._Location._Child = _Tree_child::_Right;</span><br><span class="line">                _Trynode                 = _Trynode-&gt;_Right;</span><br><span class="line">            &#125; </span><br><span class="line">            <span class="keyword">else</span> </span><br><span class="line">            &#123;</span><br><span class="line">                _Result._Location._Child = _Tree_child::_Left;</span><br><span class="line">                _Result._Bound           = _Trynode;</span><br><span class="line">                _Trynode                 = _Trynode-&gt;_Left;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> _Result;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	<span class="comment">// eqrange 函数</span></span><br><span class="line">    <span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">_Other</span>&gt;</span><br><span class="line">    pair&lt;_Nodeptr, _Nodeptr&gt; _Eqrange(<span class="type">const</span> _Other&amp; _Keyval) <span class="function"><span class="type">const</span></span></span><br><span class="line"><span class="function">        <span class="title">noexcept</span><span class="params">(_Nothrow_compare&lt;key_compare, key_type, _Other&gt;&amp;&amp; _Nothrow_compare&lt;key_compare, _Other, key_type&gt;)</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">        <span class="comment">// find range of nodes equivalent to _Keyval</span></span><br><span class="line">        <span class="type">const</span> <span class="keyword">auto</span> _Scary = _Get_scary();</span><br><span class="line">        <span class="type">const</span> <span class="keyword">auto</span>&amp; _Comp = _Getcomp();</span><br><span class="line">        _Nodeptr _Pnode   = _Scary-&gt;_Myhead-&gt;_Parent;</span><br><span class="line">        _Nodeptr _Lonode  = _Scary-&gt;_Myhead; <span class="comment">// end() if search fails</span></span><br><span class="line">        _Nodeptr _Hinode  = _Scary-&gt;_Myhead; <span class="comment">// end() if search fails</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (!_Pnode-&gt;_Isnil)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">const</span> <span class="keyword">auto</span>&amp; _Nodekey = _Traits::_Kfn(_Pnode-&gt;_Myval);</span><br><span class="line">            <span class="keyword">if</span> (_DEBUG_LT_PRED(_Comp, _Nodekey, _Keyval))</span><br><span class="line">            &#123;</span><br><span class="line">                _Pnode = _Pnode-&gt;_Right; <span class="comment">// descend right subtree</span></span><br><span class="line">            &#125; </span><br><span class="line">            <span class="keyword">else</span> </span><br><span class="line">            &#123; <span class="comment">// _Pnode not less than _Keyval, remember it</span></span><br><span class="line">                <span class="keyword">if</span> (_Hinode-&gt;_Isnil &amp;&amp; _DEBUG_LT_PRED(_Comp, _Keyval, _Nodekey))</span><br><span class="line">                &#123;</span><br><span class="line">                    _Hinode = _Pnode; <span class="comment">// _Pnode greater, remember it</span></span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                _Lonode = _Pnode;</span><br><span class="line">                _Pnode  = _Pnode-&gt;_Left; <span class="comment">// descend left subtree</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        _Pnode = _Hinode-&gt;_Isnil ? _Scary-&gt;_Myhead-&gt;_Parent : _Hinode-&gt;_Left; <span class="comment">// continue scan for upper bound</span></span><br><span class="line">        <span class="keyword">while</span> (!_Pnode-&gt;_Isnil) </span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (_DEBUG_LT_PRED(_Getcomp(), _Keyval, _Traits::_Kfn(_Pnode-&gt;_Myval))) </span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">// _Pnode greater than _Keyval, remember it</span></span><br><span class="line">                _Hinode = _Pnode;</span><br><span class="line">                _Pnode  = _Pnode-&gt;_Left; <span class="comment">// descend left subtree</span></span><br><span class="line">            &#125; </span><br><span class="line">            <span class="keyword">else</span> </span><br><span class="line">            &#123;</span><br><span class="line">                _Pnode = _Pnode-&gt;_Right; <span class="comment">// descend right subtree</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> &#123;_Lonode, _Hinode&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">	<span class="comment">// insert 函数</span></span><br><span class="line">    <span class="function"><span class="keyword">auto</span> <span class="title">insert</span><span class="params">(node_type&amp;&amp; _Handle)</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (_Handle.<span class="built_in">empty</span>()) </span><br><span class="line">        &#123;</span><br><span class="line">            <span class="function"><span class="keyword">if</span> <span class="title">constexpr</span> <span class="params">(_Multi)</span> </span></span><br><span class="line"><span class="function">            </span>&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="built_in">end</span>();</span><br><span class="line">            &#125; </span><br><span class="line">            <span class="keyword">else</span> </span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">return</span> _Insert_return_type&lt;iterator, node_type&gt;&#123;<span class="built_in">end</span>(), <span class="literal">false</span>, &#123;&#125;&#125;;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        _Check_node_allocator(_Handle);</span><br><span class="line">        <span class="type">const</span> <span class="keyword">auto</span> _Scary        = _Get_scary();</span><br><span class="line">        <span class="type">const</span> <span class="keyword">auto</span> _Attempt_node = _Handle._Getptr();</span><br><span class="line">        <span class="type">const</span> <span class="keyword">auto</span>&amp; _Keyval      = _Traits::_Kfn(_Attempt_node-&gt;_Myval);</span><br><span class="line">        _Tree_find_result&lt;_Nodeptr&gt; _Loc;</span><br><span class="line">        <span class="function"><span class="keyword">if</span> <span class="title">constexpr</span> <span class="params">(_Multi)</span> </span></span><br><span class="line"><span class="function">        </span>&#123;</span><br><span class="line">            _Loc = _Find_upper_bound(_Keyval);</span><br><span class="line">        &#125; <span class="keyword">else</span> </span><br><span class="line">        &#123;</span><br><span class="line">            _Loc = _Find_lower_bound(_Keyval);</span><br><span class="line">            <span class="keyword">if</span> (_Lower_bound_duplicate(_Loc._Bound, _Keyval)) </span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">return</span> _Insert_return_type&lt;iterator, node_type&gt;&#123;</span><br><span class="line">                    <span class="built_in">iterator</span>(_Loc._Bound, _Scary), <span class="literal">false</span>, _STD <span class="built_in">move</span>(_Handle)&#125;;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        _Check_grow_by_1();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// nothrow hereafter</span></span><br><span class="line"></span><br><span class="line">        _Attempt_node-&gt;_Left = _Scary-&gt;_Myhead;</span><br><span class="line">        <span class="comment">// _Attempt_node-&gt;_Parent handled in _Insert_node</span></span><br><span class="line">        _Attempt_node-&gt;_Right = _Scary-&gt;_Myhead;</span><br><span class="line">        _Attempt_node-&gt;_Color = _Red;</span><br><span class="line"></span><br><span class="line">        <span class="type">const</span> <span class="keyword">auto</span> _Inserted = _Scary-&gt;_Insert_node(_Loc._Location, _Handle._Release());</span><br><span class="line">        <span class="function"><span class="keyword">if</span> <span class="title">constexpr</span> <span class="params">(_Multi)</span> </span></span><br><span class="line"><span class="function">        </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">iterator</span>(_Inserted, _Scary);</span><br><span class="line">        &#125; <span class="keyword">else</span> </span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> _Insert_return_type&lt;iterator, node_type&gt;&#123;<span class="built_in">iterator</span>(_Inserted, _Scary), <span class="literal">true</span>, _STD <span class="built_in">move</span>(_Handle)&#125;;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">iterator <span class="title">insert</span><span class="params">(<span class="type">const</span> const_iterator _Hint, node_type&amp;&amp; _Handle)</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="type">const</span> <span class="keyword">auto</span> _Scary = _Get_scary();</span><br><span class="line"><span class="meta">#<span class="keyword">if</span> _ITERATOR_DEBUG_LEVEL == 2</span></span><br><span class="line">        _STL_VERIFY(_Hint._Getcont() == _Scary, <span class="string">&quot;map/set insert iterator outside range&quot;</span>);</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span> <span class="comment">// _ITERATOR_DEBUG_LEVEL == 2</span></span></span><br><span class="line">        <span class="keyword">if</span> (_Handle.<span class="built_in">empty</span>()) </span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">end</span>();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        _Check_node_allocator(_Handle);</span><br><span class="line">        <span class="type">const</span> <span class="keyword">auto</span> _Attempt_node = _Handle._Getptr();</span><br><span class="line">        <span class="type">const</span> <span class="keyword">auto</span>&amp; _Keyval      = _Traits::_Kfn(_Attempt_node-&gt;_Myval);</span><br><span class="line">        <span class="type">const</span> <span class="keyword">auto</span> _Loc          = _Find_hint(_Hint._Ptr, _Keyval);</span><br><span class="line">        <span class="keyword">if</span> (_Loc._Duplicate) </span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">iterator</span>(_Loc._Location._Parent, _Scary);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        _Check_grow_by_1();</span><br><span class="line"></span><br><span class="line">        _Attempt_node-&gt;_Left = _Scary-&gt;_Myhead;</span><br><span class="line">        <span class="comment">// _Attempt_node-&gt;_Parent handled in _Insert_node</span></span><br><span class="line">        _Attempt_node-&gt;_Right = _Scary-&gt;_Myhead;</span><br><span class="line">        _Attempt_node-&gt;_Color = _Red;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">iterator</span>(_Scary-&gt;_Insert_node(_Loc._Location, _Handle._Release()), _Scary);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li>
</ol>
<hr>
<h1 id="set"><a href="#set" class="headerlink" title="set"></a>set</h1><h2 id="set-类源码"><a href="#set-类源码" class="headerlink" title="set 类源码"></a>set 类源码</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// pr = less 默认为从小到大排序</span></span><br><span class="line"><span class="comment">// : public _tree 基于 红黑树实现 </span></span><br><span class="line"><span class="comment">// Tset_traits&lt;_Kty, _Pr, _Alloc, false&gt; ==&gt; _Mfl = flase =&gt; 不允许重复元素</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">tset_traits : </span></span><br><span class="line"><span class="comment">template &lt;class _Kty, // key/value type</span></span><br><span class="line"><span class="comment">    class _Pr, // comparator predicate type</span></span><br><span class="line"><span class="comment">    class _Alloc, // actual allocator type (should be value allocator)</span></span><br><span class="line"><span class="comment">    bool _Mfl&gt; // true if multiple equivalent keys are permitted</span></span><br><span class="line"><span class="comment">class _Tset_traits</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">_Kty</span>, <span class="keyword">class</span> <span class="title class_">_Pr</span> = less&lt;_Kty&gt;, <span class="keyword">class</span> _Alloc = allocator&lt;_Kty&gt;&gt;</span><br><span class="line"><span class="comment">// 官方注释 ordered red-black tree of key values, unique keys</span></span><br><span class="line"><span class="comment">// set 是 排序的红黑树 且只有 key 值</span></span><br><span class="line"><span class="keyword">class</span> set : <span class="keyword">public</span> _Tree&lt;_Tset_traits&lt;_Kty, _Pr, _Alloc, <span class="literal">false</span>&gt;&gt;</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span> :</span><br><span class="line">	<span class="comment">// ... 一些型别定义</span></span><br><span class="line">	</span><br><span class="line">	<span class="comment">// 可以看到 set 的构造就是利用了 基类rb_tree 的 insert 的函数</span></span><br><span class="line">    <span class="keyword">template</span> &lt;<span class="keyword">class</span> _Iter&gt;</span><br><span class="line">    <span class="built_in">set</span>(_Iter _First, _Iter _Last) : _Mybase(<span class="built_in">key_compare</span>()) &#123;</span><br><span class="line">        <span class="keyword">this</span>-&gt;<span class="built_in">insert</span>(_First, _Last);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">using</span> _Mybase::_Unchecked_begin;</span><br><span class="line">    <span class="keyword">using</span> _Mybase::_Unchecked_end;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<hr>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">这里有个奇怪的发现？ set : rb_tree 是继承的 stack/queue : deque 是成员变量的 priority_queue : heap 是成员函数的</span><br></pre></td></tr></table></figure>

<hr>
<h1 id="multiset"><a href="#multiset" class="headerlink" title="multiset"></a>multiset</h1><p>和 <code>set</code> 没啥区别，就只是 </p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">multiset</span> : <span class="keyword">public</span> _Tree&lt;_Tset_traits&lt;_Kty, _Pr, _Alloc, <span class="literal">true</span>&gt;&gt;</span><br><span class="line"><span class="comment">// ml1 = true;</span></span><br><span class="line"><span class="comment">// 即允许元素重复</span></span><br></pre></td></tr></table></figure>

<hr>
<h1 id="algorithm-算法"><a href="#algorithm-算法" class="headerlink" title="algorithm 算法"></a>algorithm 算法</h1><h2 id="ergodic-遍历类"><a href="#ergodic-遍历类" class="headerlink" title="ergodic 遍历类"></a>ergodic 遍历类</h2><h3 id="for-each"><a href="#for-each" class="headerlink" title="for_each"></a>for_each</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">_InIt</span>, <span class="keyword">class</span> <span class="title class_">_Fn</span>&gt;</span><br><span class="line"><span class="function">_CONSTEXPR20 _Fn <span class="title">for_each</span><span class="params">(_InIt _First, _InIt _Last, _Fn _Func)</span> </span></span><br><span class="line"><span class="function"></span>&#123; <span class="comment">// perform function for each element [_First, _Last)</span></span><br><span class="line">    _Adl_verify_range(_First, _Last);</span><br><span class="line">    <span class="keyword">auto</span> _UFirst      = _Get_unwrapped(_First);</span><br><span class="line">    <span class="type">const</span> <span class="keyword">auto</span> _ULast = _Get_unwrapped(_Last);</span><br><span class="line">    <span class="comment">// 核心代码 本质就是使用 beg 到 end 的元素作为参数调用 func</span></span><br><span class="line">    <span class="keyword">for</span> (; _UFirst != _ULast; ++_UFirst) </span><br><span class="line">    &#123;</span><br><span class="line">        _Func(*_UFirst);</span><br><span class="line">    &#125;</span><br><span class="line">	<span class="comment">// 返回值是 func</span></span><br><span class="line">	<span class="comment">// for_each(vec.begin(), vec.end(), func)(114514); ???? ????</span></span><br><span class="line">    <span class="keyword">return</span> _Func;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h3 id="transform"><a href="#transform" class="headerlink" title="transform"></a>transform</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">_InIt</span>, <span class="keyword">class</span> <span class="title class_">_OutIt</span>, <span class="keyword">class</span> <span class="title class_">_Fn</span>&gt;</span><br><span class="line"><span class="function">_CONSTEXPR20 _OutIt <span class="title">transform</span><span class="params">(<span class="type">const</span> _InIt _First, <span class="type">const</span> _InIt _Last, _OutIt _Dest, _Fn _Func)</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// transform [_First, _Last) with _Func</span></span><br><span class="line">    _Adl_verify_range(_First, _Last);</span><br><span class="line">    <span class="keyword">auto</span> _UFirst      = _Get_unwrapped(_First);</span><br><span class="line">    <span class="type">const</span> <span class="keyword">auto</span> _ULast = _Get_unwrapped(_Last);</span><br><span class="line">    <span class="keyword">auto</span> _UDest       = _Get_unwrapped_n(_Dest, _Idl_distance&lt;_InIt&gt;(_UFirst, _ULast));</span><br><span class="line">    <span class="comment">// 核心代码 *dest = func(*first)</span></span><br><span class="line">    <span class="keyword">for</span> (; _UFirst != _ULast; ++_UFirst, (<span class="type">void</span>) ++_UDest) </span><br><span class="line">    &#123;</span><br><span class="line">        *_UDest = _Func(*_UFirst);</span><br><span class="line">    &#125;</span><br><span class="line">	<span class="comment">// return dest</span></span><br><span class="line">    _Seek_wrapped(_Dest, _UDest);</span><br><span class="line">    <span class="keyword">return</span> _Dest;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h2 id="find-查找类"><a href="#find-查找类" class="headerlink" title="find 查找类"></a>find 查找类</h2><h3 id="find"><a href="#find" class="headerlink" title="find"></a>find</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">_InputIter</span>, <span class="keyword">class</span> <span class="title class_">_Tp</span>&gt;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> _InputIter <span class="title">find</span><span class="params">(_InputIter __first, _InputIter __last,<span class="type">const</span> _Tp&amp; __val,input_iterator_tag)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="comment">//若尚未到达区间的尾端，且未找到匹配的值，则继续查找</span></span><br><span class="line">  <span class="keyword">while</span> (__first != __last &amp;&amp; !(*__first == __val))</span><br><span class="line">    ++__first;</span><br><span class="line">  <span class="comment">//若找到匹配的值，则返回该位置</span></span><br><span class="line">  <span class="comment">//若找不到，即到达区间尾端，此时first=last，则返回first</span></span><br><span class="line">  <span class="keyword">return</span> __first;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h3 id="find-if"><a href="#find-if" class="headerlink" title="find_if"></a>find_if</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">_InIt</span>, <span class="keyword">class</span> <span class="title class_">_Pr</span>&gt;</span><br><span class="line"><span class="function">_NODISCARD _CONSTEXPR20 _InIt <span class="title">find_if</span><span class="params">(_InIt _First, <span class="type">const</span> _InIt _Last, _Pr _Pred)</span> </span></span><br><span class="line"><span class="function"></span>&#123; 	<span class="comment">// find first satisfying _Pred</span></span><br><span class="line">    _Adl_verify_range(_First, _Last);</span><br><span class="line">    <span class="keyword">auto</span> _UFirst      = _Get_unwrapped(_First);</span><br><span class="line">    <span class="type">const</span> <span class="keyword">auto</span> _ULast = _Get_unwrapped(_Last);</span><br><span class="line">    <span class="comment">// 可以看到 判定是否找到的条件可以自己设定了</span></span><br><span class="line">    <span class="keyword">for</span> (; _UFirst != _ULast; ++_UFirst) </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (_Pred(*_UFirst)) <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    _Seek_wrapped(_First, _UFirst);</span><br><span class="line">    <span class="keyword">return</span> _First;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h3 id="adjacent-find"><a href="#adjacent-find" class="headerlink" title="adjacent_find"></a>adjacent_find</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">_FwdIt</span>, <span class="keyword">class</span> <span class="title class_">_Pr</span>&gt;</span><br><span class="line"><span class="function">_NODISCARD _CONSTEXPR20 _FwdIt <span class="title">adjacent_find</span><span class="params">(<span class="type">const</span> _FwdIt _First, _FwdIt _Last, _Pr _Pred)</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// find first satisfying _Pred with successor</span></span><br><span class="line">    _Adl_verify_range(_First, _Last);</span><br><span class="line">    <span class="keyword">auto</span> _UFirst = _Get_unwrapped(_First);</span><br><span class="line">    <span class="keyword">auto</span> _ULast  = _Get_unwrapped(_Last);</span><br><span class="line">    <span class="keyword">if</span> (_UFirst != _ULast) </span><br><span class="line">    &#123;</span><br><span class="line">    	<span class="comment">// 核心代码 如果满足 func(cur,next) 就返回</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> _UNext = _UFirst; ++_UNext != _ULast; _UFirst = _UNext) &#123;</span><br><span class="line">            <span class="keyword">if</span> (_Pred(*_UFirst, *_UNext)) </span><br><span class="line">            &#123;</span><br><span class="line">                _ULast = _UFirst;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    _Seek_wrapped(_Last, _ULast);</span><br><span class="line">    <span class="keyword">return</span> _Last;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h2 id="sort-排序类"><a href="#sort-排序类" class="headerlink" title="sort 排序类"></a>sort 排序类</h2><h3 id="merge"><a href="#merge" class="headerlink" title="merge"></a>merge</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">_InIt1</span>, <span class="keyword">class</span> <span class="title class_">_InIt2</span>, <span class="keyword">class</span> <span class="title class_">_OutIt</span>, <span class="keyword">class</span> <span class="title class_">_Pr</span>&gt;</span><br><span class="line"><span class="function">_CONSTEXPR20 _OutIt <span class="title">merge</span><span class="params">(_InIt1 _First1, _InIt1 _Last1, _InIt2 _First2, _InIt2 _Last2, _OutIt _Dest, _Pr _Pred)</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// copy merging ranges</span></span><br><span class="line">    _Adl_verify_range(_First1, _Last1);</span><br><span class="line">    _Adl_verify_range(_First2, _Last2);</span><br><span class="line">    <span class="keyword">auto</span> _UFirst1      = _Get_unwrapped(_First1);</span><br><span class="line">    <span class="type">const</span> <span class="keyword">auto</span> _ULast1 = _Get_unwrapped(_Last1);</span><br><span class="line">    <span class="keyword">auto</span> _UFirst2      = _Get_unwrapped(_First2);</span><br><span class="line">    <span class="type">const</span> <span class="keyword">auto</span> _ULast2 = _Get_unwrapped(_Last2);</span><br><span class="line">    _DEBUG_ORDER_SET_UNWRAPPED(_InIt2, _UFirst1, _ULast1, _Pred);</span><br><span class="line">    _DEBUG_ORDER_SET_UNWRAPPED(_InIt1, _UFirst2, _ULast2, _Pred);</span><br><span class="line">    <span class="type">const</span> <span class="keyword">auto</span> _Count1 = _Idl_distance&lt;_InIt1&gt;(_UFirst1, _ULast1);</span><br><span class="line">    <span class="type">const</span> <span class="keyword">auto</span> _Count2 = _Idl_distance&lt;_InIt2&gt;(_UFirst2, _ULast2);</span><br><span class="line">    <span class="keyword">auto</span> _UDest        = _Get_unwrapped_n(_Dest, _Idl_dist_add(_Count1, _Count2));</span><br><span class="line">    <span class="comment">// 核心循环</span></span><br><span class="line">    <span class="keyword">if</span> (_UFirst1 != _ULast1 &amp;&amp; _UFirst2 != _ULast2) &#123;</span><br><span class="line">        <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">        	<span class="comment">// 按序COPY</span></span><br><span class="line">            <span class="keyword">if</span> (_DEBUG_LT_PRED(_Pred, *_UFirst2, *_UFirst1)) &#123;</span><br><span class="line">                *_UDest = *_UFirst2;</span><br><span class="line">                ++_UDest;</span><br><span class="line">                ++_UFirst2;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (_UFirst2 == _ULast2) &#123;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                *_UDest = *_UFirst1;</span><br><span class="line">                ++_UDest;</span><br><span class="line">                ++_UFirst1;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (_UFirst1 == _ULast1) &#123;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">	<span class="comment">// 补上没有COPY的尾巴</span></span><br><span class="line">    _UDest = _Copy_unchecked(_UFirst1, _ULast1, _UDest); <span class="comment">// copy any tail</span></span><br><span class="line">    _Seek_wrapped(_Dest, _Copy_unchecked(_UFirst2, _ULast2, _UDest));</span><br><span class="line">    <span class="keyword">return</span> _Dest;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h2 id="sort"><a href="#sort" class="headerlink" title="sort"></a>sort</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">_RanIt</span>, <span class="keyword">class</span> <span class="title class_">_Pr</span>&gt;</span><br><span class="line">_CONSTEXPR20 <span class="type">void</span> _Sort_unchecked(_RanIt _First, _RanIt _Last, _Iter_diff_t&lt;_RanIt&gt; _Ideal, _Pr _Pred)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// order [_First, _Last)</span></span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">        <span class="keyword">if</span> (_Last - _First &lt;= _ISORT_MAX) </span><br><span class="line">        &#123;   <span class="comment">// small - 当分区足够小 采用插入排序</span></span><br><span class="line">            _Insertion_sort_unchecked(_First, _Last, _Pred);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (_Ideal &lt;= <span class="number">0</span>) </span><br><span class="line">        &#123;   <span class="comment">// heap sort if too many divisions</span></span><br><span class="line">            <span class="comment">// 如果过多分区 采用堆排序</span></span><br><span class="line">            _Make_heap_unchecked(_First, _Last, _Pred);</span><br><span class="line">            _Sort_heap_unchecked(_First, _Last, _Pred);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// divide and conquer by quicksort</span></span><br><span class="line">        <span class="comment">// 快速排序分而治之</span></span><br><span class="line">        <span class="keyword">auto</span> _Mid = _Partition_by_median_guess_unchecked(_First, _Last, _Pred);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// allow 1.5 log2(N) divisions</span></span><br><span class="line">        _Ideal = (_Ideal &gt;&gt; <span class="number">1</span>) + (_Ideal &gt;&gt; <span class="number">2</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (_Mid.first - _First &lt; _Last - _Mid.second) </span><br><span class="line">        &#123; <span class="comment">// loop on second half</span></span><br><span class="line">            _Sort_unchecked(_First, _Mid.first, _Ideal, _Pred);</span><br><span class="line">            _First = _Mid.second;</span><br><span class="line">        &#125; </span><br><span class="line">        <span class="keyword">else</span> </span><br><span class="line">        &#123; <span class="comment">// loop on first half</span></span><br><span class="line">            _Sort_unchecked(_Mid.second, _Last, _Ideal, _Pred);</span><br><span class="line">            _Last = _Mid.first;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h2 id="quick-sort"><a href="#quick-sort" class="headerlink" title="quick_sort"></a>quick_sort</h2><p><strong>快速排序 采用了三数中值法 - Tukey’s ninther法</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">_RanIt</span>, <span class="keyword">class</span> <span class="title class_">_Pr</span>&gt;</span><br><span class="line">_CONSTEXPR20 pair&lt;_RanIt, _RanIt&gt; _Partition_by_median_guess_unchecked(_RanIt _First, _RanIt _Last, _Pr _Pred) </span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// partition [_First, _Last)</span></span><br><span class="line">    _RanIt _Mid = _First + ((_Last - _First) &gt;&gt; <span class="number">1</span>); <span class="comment">// shift for codegen</span></span><br><span class="line">    _Guess_median_unchecked(_First, _Mid, _Prev_iter(_Last), _Pred);</span><br></pre></td></tr></table></figure>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 补充 _Guess_median_unchecked</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">_RanIt</span>, <span class="keyword">class</span> <span class="title class_">_Pr</span>&gt;</span><br><span class="line">_CONSTEXPR20 <span class="type">void</span> _Guess_median_unchecked(_RanIt _First, _RanIt _Mid, _RanIt _Last, _Pr _Pred) </span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// sort median element to middle</span></span><br><span class="line">    <span class="comment">// 将中位数放置在 mid</span></span><br><span class="line">    <span class="keyword">using</span> _Diff        = _Iter_diff_t&lt;_RanIt&gt;;</span><br><span class="line">    <span class="type">const</span> _Diff _Count = _Last - _First;</span><br><span class="line">    <span class="keyword">if</span> (<span class="number">40</span> &lt; _Count) </span><br><span class="line">    &#123;   <span class="comment">// Tukey&#x27;s ninther</span></span><br><span class="line">        <span class="comment">// +1 can&#x27;t overflow because range was made inclusive in caller</span></span><br><span class="line">        <span class="type">const</span> _Diff _Step     = (_Count + <span class="number">1</span>) &gt;&gt; <span class="number">3</span>;</span><br><span class="line">        <span class="comment">// note: intentionally discards low-order bit</span></span><br><span class="line">        <span class="type">const</span> _Diff _Two_step = _Step &lt;&lt; <span class="number">1</span>; </span><br><span class="line">        _Med3_unchecked(_First, _First + _Step, _First + _Two_step, _Pred);</span><br><span class="line">        _Med3_unchecked(_Mid - _Step, _Mid, _Mid + _Step, _Pred);</span><br><span class="line">        _Med3_unchecked(_Last - _Two_step, _Last - _Step, _Last, _Pred);</span><br><span class="line">        _Med3_unchecked(_First + _Step, _Mid, _Last - _Step, _Pred);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        _Med3_unchecked(_First, _Mid, _Last, _Pred);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line">    _RanIt _Pfirst = _Mid;</span><br><span class="line">    _RanIt _Plast  = _Next_iter(_Pfirst);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (_First &lt; _Pfirst &amp;&amp; !_DEBUG_LT_PRED(_Pred, *_Prev_iter(_Pfirst), *_Pfirst)</span><br><span class="line">           &amp;&amp; !_Pred(*_Pfirst, *_Prev_iter(_Pfirst))) &#123;</span><br><span class="line">        --_Pfirst;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (_Plast &lt; _Last &amp;&amp; !_DEBUG_LT_PRED(_Pred, *_Plast, *_Pfirst) &amp;&amp; !_Pred(*_Pfirst, *_Plast)) &#123;</span><br><span class="line">        ++_Plast;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    _RanIt _Gfirst = _Plast;</span><br><span class="line">    _RanIt _Glast  = _Pfirst;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (;;) &#123; <span class="comment">// partition</span></span><br><span class="line">        <span class="keyword">for</span> (; _Gfirst &lt; _Last; ++_Gfirst) &#123;</span><br><span class="line">            <span class="keyword">if</span> (_DEBUG_LT_PRED(_Pred, *_Pfirst, *_Gfirst)) &#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (_Pred(*_Gfirst, *_Pfirst)) &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (_Plast != _Gfirst) &#123;</span><br><span class="line">                _STD <span class="built_in">iter_swap</span>(_Plast, _Gfirst);</span><br><span class="line">                ++_Plast;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                ++_Plast;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (; _First &lt; _Glast; --_Glast) &#123;</span><br><span class="line">            <span class="keyword">if</span> (_DEBUG_LT_PRED(_Pred, *_Prev_iter(_Glast), *_Pfirst)) &#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (_Pred(*_Pfirst, *_Prev_iter(_Glast))) &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (--_Pfirst != _Prev_iter(_Glast)) &#123;</span><br><span class="line">                _STD <span class="built_in">iter_swap</span>(_Pfirst, _Prev_iter(_Glast));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (_Glast == _First &amp;&amp; _Gfirst == _Last) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">pair</span>&lt;_RanIt, _RanIt&gt;(_Pfirst, _Plast);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (_Glast == _First) &#123; <span class="comment">// no room at bottom, rotate pivot upward</span></span><br><span class="line">            <span class="keyword">if</span> (_Plast != _Gfirst) &#123;</span><br><span class="line">                <span class="function">_STD <span class="title">iter_swap</span><span class="params">(_Pfirst, _Plast)</span></span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            ++_Plast;</span><br><span class="line">            <span class="function">_STD <span class="title">iter_swap</span><span class="params">(_Pfirst, _Gfirst)</span></span>;</span><br><span class="line">            ++_Pfirst;</span><br><span class="line">            ++_Gfirst;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (_Gfirst == _Last) &#123; <span class="comment">// no room at top, rotate pivot downward</span></span><br><span class="line">            <span class="keyword">if</span> (--_Glast != --_Pfirst) &#123;</span><br><span class="line">                _STD <span class="built_in">iter_swap</span>(_Glast, _Pfirst);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="function">_STD <span class="title">iter_swap</span><span class="params">(_Pfirst, --_Plast)</span></span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            _STD <span class="built_in">iter_swap</span>(_Gfirst, --_Glast);</span><br><span class="line">            ++_Gfirst;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h2 id="random-shuffle"><a href="#random-shuffle" class="headerlink" title="random_shuffle"></a>random_shuffle</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">_RanIt</span>, <span class="keyword">class</span> <span class="title class_">_RngFn</span>&gt;</span><br><span class="line"><span class="type">void</span> _Random_shuffle1(_RanIt _First, _RanIt _Last, _RngFn&amp; _RngFunc) </span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// shuffle [_First, _Last) using random function _RngFunc</span></span><br><span class="line">    _Adl_verify_range(_First, _Last);</span><br><span class="line">    <span class="keyword">auto</span> _UFirst      = _Get_unwrapped(_First);</span><br><span class="line">    <span class="type">const</span> <span class="keyword">auto</span> _ULast = _Get_unwrapped(_Last);</span><br><span class="line">    <span class="keyword">if</span> (_UFirst == _ULast) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">using</span> _Diff         = _Iter_diff_t&lt;_RanIt&gt;;</span><br><span class="line">    <span class="keyword">auto</span> _UTarget       = _UFirst;</span><br><span class="line">    _Diff _Target_index = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (; ++_UTarget != _ULast; ++_Target_index) </span><br><span class="line">    &#123;   <span class="comment">// randomly place an element from [_First, _Target] at _Target</span></span><br><span class="line">        <span class="comment">// 从前向后扫描 每次从[first,target]中选择一个元素和 target 换位</span></span><br><span class="line">        _Diff _Off = _RngFunc(<span class="built_in">static_cast</span>&lt;_Diff&gt;(_Target_index + <span class="number">1</span>));</span><br><span class="line">        _STL_ASSERT(<span class="number">0</span> &lt;= _Off &amp;&amp; _Off &lt;= _Target_index, <span class="string">&quot;random value out of range&quot;</span>);</span><br><span class="line">        <span class="keyword">if</span> (_Off != _Target_index) &#123; <span class="comment">// avoid self-move-assignment</span></span><br><span class="line">            <span class="function">_STD <span class="title">iter_swap</span><span class="params">(_UTarget, _UFirst + _Off)</span></span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h1 id="set集合类"><a href="#set集合类" class="headerlink" title="set集合类"></a>set集合类</h1><h2 id="set-union"><a href="#set-union" class="headerlink" title="set_union"></a>set_union</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 可以看到整个过程都是类似 merge 的</span></span><br><span class="line"><span class="comment">// 所以需要 set 有序</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">_InIt1</span>, <span class="keyword">class</span> <span class="title class_">_InIt2</span>, <span class="keyword">class</span> <span class="title class_">_OutIt</span>, <span class="keyword">class</span> <span class="title class_">_Pr</span>&gt;</span><br><span class="line"><span class="function">_CONSTEXPR20 _OutIt <span class="title">set_union</span><span class="params">(_InIt1 _First1, _InIt1 _Last1, _InIt2 _First2, _InIt2 _Last2, _OutIt _Dest, _Pr _Pred)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// OR sets [_First1, _Last1) and [_First2, _Last2)</span></span><br><span class="line">    _Adl_verify_range(_First1, _Last1);</span><br><span class="line">    _Adl_verify_range(_First2, _Last2);</span><br><span class="line">    <span class="keyword">auto</span> _UFirst1      = _Get_unwrapped(_First1);</span><br><span class="line">    <span class="type">const</span> <span class="keyword">auto</span> _ULast1 = _Get_unwrapped(_Last1);</span><br><span class="line">    <span class="keyword">auto</span> _UFirst2      = _Get_unwrapped(_First2);</span><br><span class="line">    <span class="type">const</span> <span class="keyword">auto</span> _ULast2 = _Get_unwrapped(_Last2);</span><br><span class="line">    _DEBUG_ORDER_SET_UNWRAPPED(_InIt2, _UFirst1, _ULast1, _Pred);</span><br><span class="line">    _DEBUG_ORDER_SET_UNWRAPPED(_InIt1, _UFirst2, _ULast2, _Pred);</span><br><span class="line">    <span class="keyword">auto</span> _UDest = _Get_unwrapped_unverified(_Dest);</span><br><span class="line">    <span class="keyword">for</span> (; _UFirst1 != _ULast1 &amp;&amp; _UFirst2 != _ULast2; ++_UDest) &#123;</span><br><span class="line">        <span class="keyword">if</span> (_DEBUG_LT_PRED(_Pred, *_UFirst1, *_UFirst2)) &#123; <span class="comment">// copy first</span></span><br><span class="line">            *_UDest = *_UFirst1;</span><br><span class="line">            ++_UFirst1;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (_Pred(*_UFirst2, *_UFirst1)) &#123; <span class="comment">// copy second</span></span><br><span class="line">            *_UDest = *_UFirst2;</span><br><span class="line">            ++_UFirst2;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123; <span class="comment">// advance both</span></span><br><span class="line">            *_UDest = *_UFirst1;</span><br><span class="line">            ++_UFirst1;</span><br><span class="line">            ++_UFirst2;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    _UDest = _Copy_unchecked(_UFirst1, _ULast1, _UDest);</span><br><span class="line">    _Seek_wrapped(_Dest, _Copy_unchecked(_UFirst2, _ULast2, _UDest));</span><br><span class="line">    <span class="keyword">return</span> _Dest;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


























































      </div>
      
        <div class="prev-or-next">
          <div class="post-foot-next">
            
              <a href="/2022/07/05/C-STL/" target="_self">
                <i class="iconfont icon-chevronleft"></i>
                <span>上一页</span>
              </a>
            
          </div>
          <div class="post-attach">
            <span class="post-pubtime">
              <i class="iconfont icon-updatetime" title="更新时间"></i>
              2022-07-05 16:15:05
            </span>
            
                  <span class="post-tags">
                    <i class="iconfont icon-tags" title="标签"></i>
                    
                    <span class="span--tag">
                      <a href="/tags/%E9%9D%A2%E8%AF%95/" title="面试">
                        <b>#</b> 面试
                      </a>
                    </span>
                    
                    <span class="span--tag">
                      <a href="/tags/C/" title="C++">
                        <b>#</b> C++
                      </a>
                    </span>
                    
                    <span class="span--tag">
                      <a href="/tags/STL/" title="STL">
                        <b>#</b> STL
                      </a>
                    </span>
                    
                  </span>
              
          </div>
          <div class="post-foot-prev">
            
              <a href="/2022/07/06/%E7%AE%97%E6%B3%95%E7%BB%83%E4%B9%A0%E4%B9%8B%E9%93%BE%E8%A1%A8/" target="_self">
                <span>下一页</span>
                <i class="iconfont icon-chevronright"></i>
              </a>
            
          </div>
        </div>
      
    </div>
    
  <div id="btn-catalog" class="btn-catalog">
    <i class="iconfont icon-catalog"></i>
  </div>
  <div class="post-catalog hidden" id="catalog">
    <div class="title">目录</div>
    <div class="catalog-content">
      
        <ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%E7%AE%97%E6%B3%95%E6%BA%90%E7%A0%81"><span class="toc-text">内存管理算法源码</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#vector"><span class="toc-text">vector</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#vector%E7%B1%BB%E6%BA%90%E7%A0%81"><span class="toc-text">vector类源码</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#vector%E8%BF%AD%E4%BB%A3%E5%99%A8%E6%BA%90%E7%A0%81"><span class="toc-text">vector迭代器源码</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#vector-%E5%AE%B9%E9%87%8F%E6%8B%93%E5%B1%95%E6%BA%90%E7%A0%81"><span class="toc-text">vector 容量拓展源码</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#vector-insert%E5%87%BD%E6%95%B0%E6%BA%90%E7%A0%81"><span class="toc-text">vector insert函数源码</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#list"><span class="toc-text">list</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#list-%E7%B1%BB%E6%BA%90%E7%A0%81"><span class="toc-text">list 类源码</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#list-node-%E6%BA%90%E7%A0%81"><span class="toc-text">list_node 源码</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#trait"><span class="toc-text">trait</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#deque"><span class="toc-text">deque</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#deque-%E7%B1%BB%E6%BA%90%E7%A0%81"><span class="toc-text">deque 类源码</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#deque-%E8%BF%AD%E4%BB%A3%E5%99%A8%E6%BA%90%E7%A0%81"><span class="toc-text">deque 迭代器源码</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#deque-%E7%9A%84%E6%8F%92%E5%85%A5%E5%87%BD%E6%95%B0%E6%BA%90%E7%A0%81"><span class="toc-text">deque 的插入函数源码</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#deque-%E7%9A%84-begin-%E5%92%8C-end-%E8%BF%AD%E4%BB%A3%E5%99%A8%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90"><span class="toc-text">deque 的 begin() 和 end() 迭代器源码分析</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#deque-%E8%BF%AD%E4%BB%A3%E5%99%A8-%E5%87%BD%E6%95%B0%E6%BA%90%E7%A0%81"><span class="toc-text">deque 迭代器 * 函数源码</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#stack"><span class="toc-text">stack</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#stack-%E7%B1%BB%E6%BA%90%E7%A0%81"><span class="toc-text">stack 类源码</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#queue"><span class="toc-text">queue</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#queue-%E7%B1%BB%E6%BA%90%E7%A0%81"><span class="toc-text">queue 类源码</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#heap"><span class="toc-text">heap</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#priority-queue"><span class="toc-text">priority_queue</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#priority-queue-%E7%B1%BB%E6%BA%90%E7%A0%81"><span class="toc-text">priority_queue 类源码</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#rb-tree"><span class="toc-text">rb_tree</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#Tree-node-%E6%A0%91%E7%BB%93%E7%82%B9%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E6%BA%90%E7%A0%81"><span class="toc-text">Tree_node 树结点数据结构 源码</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#rb-tree-%E7%B1%BB%E6%BA%90%E7%A0%81"><span class="toc-text">rb_tree 类源码</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#set"><span class="toc-text">set</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#set-%E7%B1%BB%E6%BA%90%E7%A0%81"><span class="toc-text">set 类源码</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#multiset"><span class="toc-text">multiset</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#algorithm-%E7%AE%97%E6%B3%95"><span class="toc-text">algorithm 算法</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#ergodic-%E9%81%8D%E5%8E%86%E7%B1%BB"><span class="toc-text">ergodic 遍历类</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#for-each"><span class="toc-text">for_each</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#transform"><span class="toc-text">transform</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#find-%E6%9F%A5%E6%89%BE%E7%B1%BB"><span class="toc-text">find 查找类</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#find"><span class="toc-text">find</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#find-if"><span class="toc-text">find_if</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#adjacent-find"><span class="toc-text">adjacent_find</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#sort-%E6%8E%92%E5%BA%8F%E7%B1%BB"><span class="toc-text">sort 排序类</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#merge"><span class="toc-text">merge</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#sort"><span class="toc-text">sort</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#quick-sort"><span class="toc-text">quick_sort</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#random-shuffle"><span class="toc-text">random_shuffle</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#set%E9%9B%86%E5%90%88%E7%B1%BB"><span class="toc-text">set集合类</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#set-union"><span class="toc-text">set_union</span></a></li></ol></li></ol>
      
    </div>
  </div>

  
<script src="/js/catalog.js"></script>




    
      <div class="comments-container">
        




  
    <script async type="text/javascript" src="/plugins/valine.min.js" onload="loadValineSuc(this)"></script>
  

  <div id="vcomments"></div>

  <script>
    function loadValineSuc() {
      new Valine({
        el: '#vcomments',
        appId: 'tJWAP21HnTAP3J9RodjBmGKN-gzGzoHsz',
        appKey: 'O55G5efQpW0frrpnzt7gFMsa',
        placeholder: 'Welcome!',
        avatar: 'retro',
        lang: 'zh-CN'
      })
    }
  </script>

    <style>
      .comments-container .v .vempty {
        display: none!important;
      }
    </style>




      </div>
    
  </div>


        
<div class="footer">
  <div class="social">
    <ul>
      
        <li>
          <a title="github" target="_blank" rel="noopener" href="https://github.com/MoyiHP">
            <i class="iconfont icon-github"></i>
          </a>
        </li>
      
    </ul>
  </div>
  
    
    <div class="footer-more">
      
        <a target="_blank" rel="noopener" href="https://github.com/zchengsite/hexo-theme-oranges">Copyright © 2022 Oranges</a>
        
    </div>
  
    
    <div class="footer-more">
      
        <a target="_blank" rel="noopener" href="https://github.com/zchengsite/hexo-theme-oranges">Theme by Oranges | Powered by Hexo</a>
        
    </div>
  
</div>

      </div>

      <div class="tools-bar">
        <div class="back-to-top tools-bar-item hidden">
  <a href="javascript: void(0)">
    <i class="iconfont icon-chevronup"></i>
  </a>
</div>


<script src="/js/backtotop.js"></script>



        
  <div class="search-icon tools-bar-item" id="search-icon">
    <a href="javascript: void(0)">
      <i class="iconfont icon-search"></i>
    </a>
  </div>

  <div class="search-overlay hidden">
    <div class="search-content" tabindex="0">
      <div class="search-title">
        <span class="search-icon-input">
          <a href="javascript: void(0)">
            <i class="iconfont icon-search"></i>
          </a>
        </span>
        
          <input type="text" class="search-input" id="search-input" placeholder="搜索...">
        
        <span class="search-close-icon" id="search-close-icon">
          <a href="javascript: void(0)">
            <i class="iconfont icon-close"></i>
          </a>
        </span>
      </div>
      <div class="search-result" id="search-result"></div>
    </div>
  </div>

  <script type="text/javascript">
    var inputArea = document.querySelector("#search-input")
    var searchOverlayArea = document.querySelector(".search-overlay")

    inputArea.onclick = function() {
      getSearchFile()
      this.onclick = null
    }

    inputArea.onkeydown = function() {
      if(event.keyCode == 13)
        return false
    }

    function openOrHideSearchContent() {
      let isHidden = searchOverlayArea.classList.contains('hidden')
      if (isHidden) {
        searchOverlayArea.classList.remove('hidden')
        document.body.classList.add('hidden')
        // inputArea.focus()
      } else {
        searchOverlayArea.classList.add('hidden')
        document.body.classList.remove('hidden')
      }
    }

    function blurSearchContent(e) {
      if (e.target === searchOverlayArea) {
        openOrHideSearchContent()
      }
    }

    document.querySelector("#search-icon").addEventListener("click", openOrHideSearchContent, false)
    document.querySelector("#search-close-icon").addEventListener("click", openOrHideSearchContent, false)
    searchOverlayArea.addEventListener("click", blurSearchContent, false)

    var searchFunc = function (path, search_id, content_id) {
      'use strict';
      var $input = document.getElementById(search_id);
      var $resultContent = document.getElementById(content_id);
      $resultContent.innerHTML = "<ul><span class='local-search-empty'>首次搜索，正在载入索引文件，请稍后……<span></ul>";
      $.ajax({
        // 0x01. load xml file
        url: path,
        dataType: "xml",
        success: function (xmlResponse) {
          // 0x02. parse xml file
          var datas = $("entry", xmlResponse).map(function () {
            return {
              title: $("title", this).text(),
              content: $("content", this).text(),
              url: $("url", this).text()
            };
          }).get();
          $resultContent.innerHTML = "";

          $input.addEventListener('input', function () {
            // 0x03. parse query to keywords list
            var str = '<ul class=\"search-result-list\">';
            var keywords = this.value.trim().toLowerCase().split(/[\s\-]+/);
            $resultContent.innerHTML = "";
            if (this.value.trim().length <= 0) {
              return;
            }
            // 0x04. perform local searching
            datas.forEach(function (data) {
              var isMatch = true;
              var content_index = [];
              if (!data.title || data.title.trim() === '') {
                data.title = "Untitled";
              }
              var orig_data_title = data.title.trim();
              var data_title = orig_data_title.toLowerCase();
              var orig_data_content = data.content.trim().replace(/<[^>]+>/g, "");
              var data_content = orig_data_content.toLowerCase();
              var data_url = data.url;
              var index_title = -1;
              var index_content = -1;
              var first_occur = -1;
              // only match artiles with not empty contents
              if (data_content !== '') {
                keywords.forEach(function (keyword, i) {
                  index_title = data_title.indexOf(keyword);
                  index_content = data_content.indexOf(keyword);

                  if (index_title < 0 && index_content < 0) {
                    isMatch = false;
                  } else {
                    if (index_content < 0) {
                      index_content = 0;
                    }
                    if (i == 0) {
                      first_occur = index_content;
                    }
                    // content_index.push({index_content:index_content, keyword_len:keyword_len});
                  }
                });
              } else {
                isMatch = false;
              }
              // 0x05. show search results
              if (isMatch) {
                str += "<li><a href='" + data_url + "' class='search-result-title'>" + orig_data_title + "</a>";
                var content = orig_data_content;
                if (first_occur >= 0) {
                  // cut out 100 characters
                  var start = first_occur - 20;
                  var end = first_occur + 80;

                  if (start < 0) {
                    start = 0;
                  }

                  if (start == 0) {
                    end = 100;
                  }

                  if (end > content.length) {
                    end = content.length;
                  }

                  var match_content = content.substr(start, end);

                  // highlight all keywords
                  keywords.forEach(function (keyword) {
                    var regS = new RegExp(keyword, "gi");
                    match_content = match_content.replace(regS, "<span class=\"search-keyword\">" + keyword + "</span>");
                  });

                  str += "<p class=\"search-result-abstract\">" + match_content + "...</p>"
                }
                str += "</li>";
              }
            });
            str += "</ul>";
            if (str.indexOf('<li>') === -1) {
              return $resultContent.innerHTML = "<ul><span class='local-search-empty'>没有找到内容，请尝试更换检索词。<span></ul>";
            }
            $resultContent.innerHTML = str;
          });
        },
        error: function(xhr, status, error) {
          $resultContent.innerHTML = ""
          if (xhr.status === 404) {
            $resultContent.innerHTML = "<ul><span class='local-search-empty'>未找到search.xml文件，具体请参考：<a href='https://github.com/zchengsite/hexo-theme-oranges#configuration' target='_black'>configuration</a><span></ul>";
          } else {
            $resultContent.innerHTML = "<ul><span class='local-search-empty'>请求失败，尝试重新刷新页面或稍后重试。<span></ul>";
          }
        }
      });
      $(document).on('click', '#search-close-icon', function() {
        $('#search-input').val('');
        $('#search-result').html('');
      });
    }

    var getSearchFile = function() {
        var path = "/search.xml";
        searchFunc(path, 'search-input', 'search-result');
    }
  </script>




        
  <div class="tools-bar-item theme-icon" id="switch-color-scheme">
    <a href="javascript: void(0)">
      <i id="theme-icon" class="iconfont icon-moon"></i>
    </a>
  </div>

  
<script src="/js/colorscheme.js"></script>





        

      </div>
    </div>
  </body>
</html>
