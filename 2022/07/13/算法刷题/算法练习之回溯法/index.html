<!DOCTYPE html>
<html lang="zh-CN" color-mode="light">

  <head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <meta name="keywords" content="" />
  <meta name="author" content="ZHI XING" />
  <meta name="description" content="" />
  
  
  <title>
    
      算法练习之回溯法 
      
      
      |
    
     BLOG
  </title>

  
    <link rel="apple-touch-icon" href="/images/favicon.png">
    <link rel="icon" href="/images/favicon.png">
  

  <!-- Raleway-Font -->
  <link href="https://fonts.googleapis.com/css?family=Raleway&display=swap" rel="stylesheet">

  <!-- hexo site css -->
  
<link rel="stylesheet" href="/css/color-scheme.css">
<link rel="stylesheet" href="/css/base.css">
<link rel="stylesheet" href="//at.alicdn.com/t/font_1886449_67xjft27j1l.css">
<link rel="stylesheet" href="/css/github-markdown.css">
<link rel="stylesheet" href="/css/highlight.css">
<link rel="stylesheet" href="/css/comments.css">

  <!-- 代码块风格 -->
  
    
<link rel="stylesheet" href="/css/figcaption/mac-block.css">

  

  <!-- jquery3.3.1 -->
  
    <script defer type="text/javascript" src="/plugins/jquery.min.js"></script>
  

  <!-- fancybox -->
  
    <link href="/plugins/jquery.fancybox.min.css" rel="stylesheet">
    <script defer type="text/javascript" src="/plugins/jquery.fancybox.min.js"></script>
  
  
<script src="/js/fancybox.js"></script>


  
    <!-- Global site tag (gtag.js) - Google Analytics -->
    <script async src="https://www.googletagmanager.com/gtag/js?id=G-H7TKYSEWBY"></script>
    <script>
      window.dataLayer = window.dataLayer || [];
      function gtag(){dataLayer.push(arguments);}
      gtag('js', new Date());

      gtag('config', 'G-H7TKYSEWBY');
    </script>
  

  <script>
    var html = document.documentElement
    const colorMode = localStorage.getItem('color-mode')
    if (colorMode) {
      document.documentElement.setAttribute('color-mode', colorMode)
    }
  </script>
<meta name="generator" content="Hexo 6.2.0"></head>


  <body>
    <div id="app">
      <div class="header">
  <div class="avatar">
    <a href="/">
      <!-- 头像取消懒加载，添加no-lazy -->
      
        <img no-lazy src="/images/avatar.png" alt="">
      
    </a>
    <div class="nickname"><a href="/">Oranges Blogs</a></div>
  </div>
  <div class="navbar">
    <ul>
      
        <li class="nav-item" data-path="/">
          <a href="/">Home</a>
        </li>
      
        <li class="nav-item" data-path="/archives/">
          <a href="/archives/">Archives</a>
        </li>
      
        <li class="nav-item" data-path="/tags/">
          <a href="/tags/">Tags</a>
        </li>
      
        <li class="nav-item" data-path="/friends/">
          <a href="/friends/">Friends</a>
        </li>
      
        <li class="nav-item" data-path="/about/">
          <a href="/about/">About</a>
        </li>
      
    </ul>
  </div>
</div>


<script src="/js/activeNav.js"></script>



      <div class="flex-container">
        <!-- 文章详情页，展示文章具体内容，url形式：https://yoursite/文章标题/ -->
<!-- 同时为「标签tag」，「朋友friend」，「分类categories」，「关于about」页面的承载页面，具体展示取决于page.type -->


  <!-- LaTex Display -->

  
    <script async type="text/javascript" src="/plugins/mathjax/tex-chtml.js"></script>
  
  <script>
    MathJax = {
      tex: {
        inlineMath: [['$', '$'], ['\\(', '\\)']]
      }
    }
  </script>





  <!-- clipboard -->

  
    <script async type="text/javascript" src="/plugins/clipboard.min.js"></script>
  
  
<script src="/js/codeCopy.js"></script>







  

  

  

  
  <!-- 文章内容页 url形式：https://yoursite/文章标题/ -->
  <div class="container post-details" id="post-details">
    <div class="post-content">
      <div class="post-title">算法练习之回溯法</div>
      <div class="post-attach">
        <span class="post-pubtime">
          <i class="iconfont icon-updatetime" title="更新时间"></i>
          2022-07-13 15:35:37
        </span>
        
              <span class="post-tags">
                <i class="iconfont icon-tags" title="标签"></i>
                
                <span class="span--tag">
                  <a href="/tags/%E9%9D%A2%E8%AF%95/" title="面试">
                    <b>#</b> 面试
                  </a>
                </span>
                
                <span class="span--tag">
                  <a href="/tags/C/" title="C++">
                    <b>#</b> C++
                  </a>
                </span>
                
                <span class="span--tag">
                  <a href="/tags/%E7%AE%97%E6%B3%95/" title="算法">
                    <b>#</b> 算法
                  </a>
                </span>
                
              </span>
          
      </div>
      <div class="markdown-body">
        <p><em>代码随想录 学习刷题笔记</em><br><em>题目来自力扣网</em></p>
<h1 id="理论基础"><a href="#理论基础" class="headerlink" title="理论基础"></a>理论基础</h1><ul>
<li>回溯法&#x2F;回溯搜索法，是一种基于递归与穷举的算法，因为本质上是在解空间上的深度优先遍历，类似穷举，它的效率并不高</li>
<li>常见的可以利用回溯法解决的问题类型有如下，共同特点在所有集合&#x2F;排列中寻找符合条件的集合&#x2F;排列<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">1. 组合类问题 如从N个数中按照一定规则找到K个数的集合</span><br><span class="line">2. 切割类问题 如一个字符串中按照一定规则有几种切分方式</span><br><span class="line">3. 子集类问题 如一个N个数的集合有多少符合条件的子集</span><br><span class="line">4. 排列类问题 如N个数按照一定规则有几种可能的排列方式</span><br><span class="line">5. 棋盘类问题 如N皇后问题、求解数独</span><br><span class="line">说明</span><br><span class="line">组合 和 排列 是两个不同的概念，组合不讲求元素的先后顺序，&#123;1,2&#125;和&#123;2,1&#125;是两个相同的组合；排列讲究元素的先后顺序&#123;1,2&#125;和&#123;2,1&#125;是两个不同的排列</span><br></pre></td></tr></table></figure></li>
<li>回溯法所解决的问题均可以抽象为<strong>树形结构</strong>，集合的大小决定了树的宽度，递归的深度决定了树的深度<pre class="mermaid">graph
ROOT((ROOT))
S1((S1))
S2((S2))
SI((s.))
SN((SN))
S12((S12))
S13((S13))
S1I((S1.))
S1N((S1N))
ROOT --> S1
ROOT --> S2
ROOT --> SI
ROOT --> SN
S1 --> S12
S1 --> S13
S1 --> S1I
S1 --> S1N</pre></li>
<li>回溯法的算法模板<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 1. 回溯函数的返回值一般为void, 因为回溯函数大都是求解所有的可能解,所以一般会有全局变量来存储可能解</span></span><br><span class="line"><span class="comment">// 2. 回溯函数的参数一般是不固定的, 需要根据实际逻辑需要补充</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">backtracking</span><span class="params">(参数)</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="comment">// 3. 回溯函数是需要有终止条件的</span></span><br><span class="line">	<span class="comment">// 一般的终止条件是 到达叶子节点了无法继续深入 | 当前状态已经满足条件了 | 当前状态继续递归下去没有可能满足条件了(剪枝)</span></span><br><span class="line">    <span class="keyword">if</span> (终止条件) </span><br><span class="line">    &#123;</span><br><span class="line">        存放结果;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 在本层上的搜索就是一个for循环来实现</span></span><br><span class="line">    <span class="keyword">for</span> (选择：本层集合中元素（树中节点孩子的数量就是集合的大小）) </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 根据本层的每种可能发展 进行处理</span></span><br><span class="line">        处理节点;</span><br><span class="line">        <span class="comment">// 递归</span></span><br><span class="line">        <span class="built_in">backtracking</span>(路径，选择列表);</span><br><span class="line">        回溯，撤销处理结果</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<hr>
<h1 id="1-组合类问题"><a href="#1-组合类问题" class="headerlink" title="1. 组合类问题"></a>1. 组合类问题</h1><ul>
<li>由于组合存在一个 不考虑元素先后顺序的特性存在，在实际解决问题时往往可以不妨假设我们按某种顺序来选择元素</li>
</ul>
<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><h3 id="T77-组合"><a href="#T77-组合" class="headerlink" title="T77 组合"></a>T77 组合</h3><p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/combinations/">https://leetcode.cn/problems/combinations/</a><br>给定两个整数 n 和 k，返回范围 [1, n] 中所有可能的 k 个数的组合。你可以按 任何顺序 返回答案。<br><strong>分析</strong></p>
<ul>
<li>这是一个组合类的问题，适用于回溯法来解决</li>
<li>回溯法本质上仍旧是暴力搜索，但简单的 for 循环嵌套是没办法解决这个题目的，因为 很明显使用嵌套for循环的话需要K层for循环，但是 K 的值是不确定的</li>
<li>由于是组合类问题，组合对于元素的排列顺序是不敏感的，也就是说对于 {1,2} 和 {2,1} 这两种情况，有且只有一个需要保留，那么，在考虑元素选定的时候，就完全可以从左往右依次考虑了</li>
<li>回溯法的三部曲</li>
<li><ul>
<li>函数返回值 \ 函数参数 \ 当前状态的定义<br>首先需要定义的是 符合条件的结果存放容器，由于这里是多个整数的组合，所以可以确定为<code>vector&lt;vector&lt;int&gt;&gt; res</code><br>然后需要定义当前状态，由分析可以得知，当前的状态包括1. 当前已经选择的整数的结合<code>vector&lt;int&gt; path</code> 2. 当前可选择范围<code>[start,n]</code><br>函数参数的确定基于上述讨论，可以将上述数据结构作为函数参数，此时注意res通常需要采用引用的形式；也可以将它们作为全局变量来保证回溯函数可访问<br>所以此时的回溯函数可写为<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; res;</span><br><span class="line"><span class="function">vector&lt;<span class="type">int</span>&gt; path</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">backtrack</span><span class="params">(<span class="type">int</span> start, <span class="type">int</span> n, <span class="type">int</span> k)</span></span>&#123;&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><ul>
<li>递归结束条件的确定<br>这里很简单，当当前路径中的元素个数达到K即可<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; res;</span><br><span class="line"><span class="function">vector&lt;<span class="type">int</span>&gt; path</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">backtrack</span><span class="params">(<span class="type">int</span> start, <span class="type">int</span> n, <span class="type">int</span> k)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(path.<span class="built_in">size</span>() == k)</span><br><span class="line">	&#123;</span><br><span class="line">		res.<span class="built_in">push_back</span>(path);</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><ul>
<li>本层的搜索 <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; res;</span><br><span class="line"><span class="function">vector&lt;<span class="type">int</span>&gt; path</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">backtrack</span><span class="params">(<span class="type">int</span> start, <span class="type">int</span> n, <span class="type">int</span> k)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(path.<span class="built_in">size</span>() == k)</span><br><span class="line">	&#123;</span><br><span class="line">		res.<span class="built_in">push_back</span>(path);</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i = start; i &lt;= n; i++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="comment">// 处理</span></span><br><span class="line">		path.<span class="built_in">push_back</span>(i);</span><br><span class="line">		<span class="comment">// 递归</span></span><br><span class="line">		<span class="comment">// 逆天错误....backtrack(start+1,n,k);</span></span><br><span class="line">		<span class="built_in">backtrack</span>(i+<span class="number">1</span>,n,k);</span><br><span class="line">		<span class="comment">// 回溯</span></span><br><span class="line">		path.<span class="built_in">pop_back</span>();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li>剪枝优化 进行本层搜索时真的有必要搜索所有的元素吗？因为总需要元素个数为K个，当前已经选择元素为 path.size() 个，那么剩下的元素个数 n - i + 1 至少要大于等于 K - path.size() ，所以 <code>i &lt;= n + 1 - k + path.size()</code></li>
</ul>
<hr>
<p><strong>代码</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> </span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; res;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; path;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">backtrack</span><span class="params">(<span class="type">int</span> start, <span class="type">int</span> n, <span class="type">int</span> k)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="comment">// 终止条件</span></span><br><span class="line">        <span class="keyword">if</span> (path.<span class="built_in">size</span>() == k)</span><br><span class="line">        &#123;</span><br><span class="line">            res.<span class="built_in">push_back</span>(path);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 本层搜索</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = start; i &lt;= n + <span class="number">1</span> - k + path.<span class="built_in">size</span>(); i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// 处理</span></span><br><span class="line">            path.<span class="built_in">push_back</span>(i);</span><br><span class="line">            <span class="comment">// 递归</span></span><br><span class="line">            <span class="built_in">backtrack</span>(i + <span class="number">1</span>, n, k);</span><br><span class="line">            <span class="comment">// 回溯</span></span><br><span class="line">            path.<span class="built_in">pop_back</span>();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">combine</span>(<span class="type">int</span> n, <span class="type">int</span> k) </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">backtrack</span>(<span class="number">1</span>, n, k);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<hr>
<h3 id="T216-组合总和III"><a href="#T216-组合总和III" class="headerlink" title="T216 组合总和III"></a>T216 组合总和III</h3><p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/combination-sum-iii/">https://leetcode.cn/problems/combination-sum-iii/</a><br>找出所有相加之和为 n 的 k 个数的组合，且满足下列条件：1. 只使用数字1到9 \ 2. 每个数字 最多使用一次 ；返回 所有可能的有效组合的列表 。该列表不能包含相同的组合两次，组合可以以任何顺序返回。</p>
<ul>
<li>类似T77 组合 多加了一个条件<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> </span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; res;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; path;</span><br><span class="line">    <span class="type">int</span> sum = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">backtrack</span><span class="params">(<span class="type">int</span> k, <span class="type">int</span> n, <span class="type">int</span> start)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (path.<span class="built_in">size</span>() == k &amp;&amp; sum == n)</span><br><span class="line">        &#123;</span><br><span class="line">            res.<span class="built_in">push_back</span>(path);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (sum &gt; n)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = start; i &lt;= <span class="number">9</span> - (k - path.<span class="built_in">size</span>()) + <span class="number">1</span>; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// 处理</span></span><br><span class="line">            sum += i;</span><br><span class="line">            path.<span class="built_in">push_back</span>(i);</span><br><span class="line">            <span class="comment">// 递归</span></span><br><span class="line">            <span class="built_in">backtrack</span>(k, n, i + <span class="number">1</span>);</span><br><span class="line">            <span class="comment">// 回溯</span></span><br><span class="line">            sum -= i;</span><br><span class="line">            path.<span class="built_in">pop_back</span>();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">combinationSum3</span>(<span class="type">int</span> k, <span class="type">int</span> n) </span><br><span class="line">    &#123;</span><br><span class="line">        res.<span class="built_in">clear</span>();</span><br><span class="line">        path.<span class="built_in">clear</span>();</span><br><span class="line">        <span class="built_in">backtrack</span>(k, n, <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li>
</ul>
<hr>
<h3 id="T17-电话号码的字母组合"><a href="#T17-电话号码的字母组合" class="headerlink" title="T17 电话号码的字母组合"></a>T17 电话号码的字母组合</h3><p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/letter-combinations-of-a-phone-number/">https://leetcode.cn/problems/letter-combinations-of-a-phone-number/</a><br>给定一个仅包含数字 2-9 的字符串，返回所有它能表示的字母组合<br>答案可以按 任意顺序 返回<br>数字到字母的映射与电话按键相同</p>
<ul>
<li>大体思路仍旧是不变的，注意表的使用<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> </span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    string digits;</span><br><span class="line">    vector&lt;string&gt; res;</span><br><span class="line">    string path;</span><br><span class="line">    map&lt;<span class="type">char</span>, string&gt; table = &#123;</span><br><span class="line">        &#123;<span class="string">&#x27;1&#x27;</span>,<span class="string">&quot;&quot;</span>&#125;,</span><br><span class="line">        &#123;<span class="string">&#x27;2&#x27;</span>,<span class="string">&quot;abc&quot;</span>&#125;,</span><br><span class="line">        &#123;<span class="string">&#x27;3&#x27;</span>,<span class="string">&quot;def&quot;</span>&#125;,</span><br><span class="line">        &#123;<span class="string">&#x27;4&#x27;</span>,<span class="string">&quot;ghi&quot;</span>&#125;,</span><br><span class="line">        &#123;<span class="string">&#x27;5&#x27;</span>,<span class="string">&quot;jkl&quot;</span>&#125;,</span><br><span class="line">        &#123;<span class="string">&#x27;6&#x27;</span>,<span class="string">&quot;mno&quot;</span>&#125;,</span><br><span class="line">        &#123;<span class="string">&#x27;7&#x27;</span>,<span class="string">&quot;pqrs&quot;</span>&#125;,</span><br><span class="line">        &#123;<span class="string">&#x27;8&#x27;</span>,<span class="string">&quot;tuv&quot;</span>&#125;,</span><br><span class="line">        &#123;<span class="string">&#x27;9&#x27;</span>,<span class="string">&quot;wxyz&quot;</span>&#125;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">backtrack</span><span class="params">(<span class="type">int</span> cur)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (path.<span class="built_in">size</span>() == digits.<span class="built_in">size</span>())</span><br><span class="line">        &#123;</span><br><span class="line">            res.<span class="built_in">push_back</span>(path);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">char</span> ch : table[digits[cur]])</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// 处理</span></span><br><span class="line">            path.<span class="built_in">push_back</span>(ch);</span><br><span class="line">            <span class="comment">// 递归</span></span><br><span class="line">            <span class="built_in">backtrack</span>(cur + <span class="number">1</span>);</span><br><span class="line">            <span class="comment">// 回溯</span></span><br><span class="line">            path.<span class="built_in">pop_back</span>();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;string&gt; <span class="title">letterCombinations</span><span class="params">(string digits)</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (digits.<span class="built_in">size</span>() == <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> res;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">this</span>-&gt;digits = digits;</span><br><span class="line">        <span class="built_in">backtrack</span>(<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li>
</ul>
<hr>
<h3 id="T39-组合总和"><a href="#T39-组合总和" class="headerlink" title="T39 组合总和"></a>T39 组合总和</h3><p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/combination-sum/">https://leetcode.cn/problems/combination-sum/</a><br>给你一个 无重复元素 的整数数组 candidates 和一个目标整数 target ，找出 candidates 中可以使数字和为目标数 target 的 所有 不同组合 ，并以列表形式返回。你可以按 任意顺序 返回这些组合。<br>candidates 中的 同一个 数字可以 无限制重复被选取 。如果至少一个数字的被选数量不同，则两种组合是不同的。 <br>对于给定的输入，保证和为 target 的不同组合数少于 150 个。</p>
<ul>
<li>这个问题相较于之前的问题有两点不同</li>
<li><ul>
<li>第一、同一个数字可以被重复的选取</li>
</ul>
</li>
<li><ul>
<li>第二、组合的元素个数没有限制</li>
</ul>
</li>
<li>所以需要考虑</li>
<li><ul>
<li>第一、为了方便，将数组 candidates 做排序，从而由小到大的考虑，避免出现 ABA AAB 的重复组合的判定的问题</li>
</ul>
</li>
<li><ul>
<li>第二、由于可以重复的考虑元素，每次递归调用时的 下一层的选择范围时 i,n； 是不用加一的</li>
</ul>
</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> </span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; res;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; path;</span><br><span class="line">    <span class="type">int</span> sum = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">backtrack</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; candidates, <span class="type">int</span> target, <span class="type">int</span> start)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (sum == target)</span><br><span class="line">        &#123;</span><br><span class="line">            res.<span class="built_in">push_back</span>(path);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (sum &gt; target)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = start; i &lt;= candidates.<span class="built_in">size</span>() - <span class="number">1</span> &amp;&amp; sum + candidates[i] &lt;= target ; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// 处理</span></span><br><span class="line">            path.<span class="built_in">push_back</span>(candidates[i]);</span><br><span class="line">            sum += candidates[i];</span><br><span class="line">            <span class="comment">// 递归</span></span><br><span class="line">            <span class="comment">// 不妨假设是有序的选择元素</span></span><br><span class="line">            <span class="built_in">backtrack</span>(candidates, target, i);</span><br><span class="line">            <span class="comment">// 回溯</span></span><br><span class="line">            sum -= candidates[i];</span><br><span class="line">            path.<span class="built_in">pop_back</span>();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">combinationSum</span>(vector&lt;<span class="type">int</span>&gt;&amp; candidates, <span class="type">int</span> target) </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">sort</span>(candidates.<span class="built_in">begin</span>(), candidates.<span class="built_in">end</span>());</span><br><span class="line">        <span class="built_in">backtrack</span>(candidates, target, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<hr>
<h3 id="T40-组合总和"><a href="#T40-组合总和" class="headerlink" title="T40 组合总和"></a>T40 组合总和</h3><p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/combination-sum-ii/">https://leetcode.cn/problems/combination-sum-ii/</a><br>给定一个候选人编号的集合 candidates 和一个目标数 target ，找出 candidates 中所有可以使数字和为 target 的组合。<br>candidates 中的每个数字在每个组合中只能使用 一次 。<br><code>注意：解集不能包含重复的组合</code></p>
<p><em>这个题目的核心点在于重复元素与去重 很棒的理解</em><br>参考：<br><a target="_blank" rel="noopener" href="https://programmercarl.com/0040.%E7%BB%84%E5%90%88%E6%80%BB%E5%92%8CII.html#%E5%9B%9E%E6%BA%AF%E4%B8%89%E9%83%A8%E6%9B%B2">https://programmercarl.com/0040.%E7%BB%84%E5%90%88%E6%80%BB%E5%92%8CII.html#%E5%9B%9E%E6%BA%AF%E4%B8%89%E9%83%A8%E6%9B%B2</a></p>
<p><strong>思路！</strong></p>
<ul>
<li>这个题目最大的特点在于 原生数组candidates是存在重复元素的，如{A,A,B}；结果组合中也是包含重复元素的，即可以有{A,A,B}，但是所有的结果组合中不能存在重复的组合，即不能有{A,X,B}和{X,A,B,}(X代表该位置上的元素没有选取)</li>
<li>首先一点，为了能够在遍历选择元素的时候能够发现重复元素，同时组合也有元素先后顺序不敏感的特点，首先要对原数组做排序，<strong>排序是去重的基础</strong></li>
<li>此时，再来看 <code>元素重复</code> 与 <code>组合重复</code> 这两个概念在回溯代码上的体现</li>
<li><ul>
<li>元素重复结合上一题（T39）可以发现，是发生在 <code>由本层向下一层 确定下一层可选择元素范围</code>的时候发生的，是<code>发生在树的一条枝干上的</code>，如果我们要对某一个结果内的元素去重，这是<code>树枝去重</code>，是<code>确定下一层的可选择元素范围的时候，跳过所有与当前选择元素相等的元素</code></li>
</ul>
</li>
<li><ul>
<li>组合重复，是发生在<code>本层选择/未有了当前元素,下一层未选择/选择了下一元素，而下一元素与当前元素相等</code>的情况下的，是<code>发生在树的某个树层上的</code>，如果我们要对某一个结果集内的结果组合去重，这是<code>树层去重</code>，是<code>在本层选择元素的时候，对相等的元素只选择一次</code></li>
</ul>
</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> </span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; res;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; path;</span><br><span class="line">    <span class="type">int</span> sum = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">backtrack</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; candidates, <span class="type">int</span> target, <span class="type">int</span> start)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (sum == target)</span><br><span class="line">        &#123;</span><br><span class="line">            res.<span class="built_in">push_back</span>(path);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (sum &gt; target)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> last = <span class="number">0</span>;   <span class="comment">// 1 &lt;= candidates[i] &lt;= 50</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = start; i &lt;= candidates.<span class="built_in">size</span>() - <span class="number">1</span> &amp;&amp;  sum + candidates[i] &lt;= target; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// 本层不能选择重复的元素</span></span><br><span class="line">            <span class="keyword">if</span> (candidates[i] &gt; last)</span><br><span class="line">            &#123;</span><br><span class="line">                last = candidates[i];</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 处理</span></span><br><span class="line">                path.<span class="built_in">push_back</span>(candidates[i]);</span><br><span class="line">                sum += candidates[i];</span><br><span class="line">                <span class="comment">// 递归</span></span><br><span class="line">                <span class="built_in">backtrack</span>(candidates, target, i + <span class="number">1</span>);</span><br><span class="line">                <span class="comment">// 回溯</span></span><br><span class="line">                sum -= candidates[i];</span><br><span class="line">                path.<span class="built_in">pop_back</span>();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">combinationSum2</span>(vector&lt;<span class="type">int</span>&gt;&amp; candidates, <span class="type">int</span> target) </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">sort</span>(candidates.<span class="built_in">begin</span>(), candidates.<span class="built_in">end</span>());</span><br><span class="line">        <span class="built_in">backtrack</span>(candidates, target, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<hr>
<h1 id="2-切割问题"><a href="#2-切割问题" class="headerlink" title="2. 切割问题"></a>2. 切割问题</h1><h2 id="理论部分"><a href="#理论部分" class="headerlink" title="理论部分"></a>理论部分</h2><ul>
<li>切割问题的本质是组合问题的衍生，它与组合问题的异同点在于</li>
<li><ul>
<li>它们都是在一个序列上选择一定数量的元素&#x2F;位置，组合问题将元素放在一起成为组合，切割问题将这些位置选择出来从而切分出了一系列子串</li>
</ul>
</li>
<li><ul>
<li>组合问题的终止&#x2F;限制条件和元素的选择依据是基于组合的，切割问题的终止&#x2F;限制条件和位置的选择依据是基于子串的</li>
</ul>
</li>
</ul>
<h2 id="题目-1"><a href="#题目-1" class="headerlink" title="题目"></a>题目</h2><h3 id="T131-分割回文串"><a href="#T131-分割回文串" class="headerlink" title="T131 分割回文串"></a>T131 分割回文串</h3><p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/palindrome-partitioning/">https://leetcode.cn/problems/palindrome-partitioning/</a><br>给你一个字符串 s，请你将 s 分割成一些子串，使每个子串都是 回文串 。返回 s 所有可能的分割方案。 回文串 是正着读和反着读都一样的字符串。<br><strong>分析</strong> </p>
<ul>
<li>两个核心点，一是分割，二是回文的判定</li>
<li>分割的方法是回溯法，</li>
<li><ul>
<li>第一步 定参数 ： 需要的数据结构有<code>记录结果集合的vector&lt;vector&lt;string&gt;&gt; res</code>和<code>记录当前切分的vector&lt;string&gt; path</code>，此外还需要一个记录当前其实点的<code>int start</code><br><em>注意到这里路径记录的就是子串了，对比组合问题中的path记录的是选取的元素组成的组合，这里可以很明显的感受到组合问题与切割问题的核心点的不同</em></li>
</ul>
</li>
<li><ul>
<li>第二步 定终止条件 ： 当字符串被全部切分的时候，即<code>start &gt;= size</code>的时候，说明其已经被完全切分了</li>
</ul>
</li>
<li><ul>
<li>第三步 定搜索逻辑 ： 当前层的任务就是在 string[start,size()-1]中找到一个以 start打头的子串[start,i]，如果可以找到，下一层的搜索范围就是[i+1,size()-1]</li>
</ul>
</li>
<li>回文的判定可以采用双指针 - 前后指针法</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> </span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    vector&lt;vector&lt;string&gt;&gt; res;</span><br><span class="line">    vector&lt;string&gt; path;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">backtrack</span><span class="params">(string s, <span class="type">int</span> start)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (start &gt;= s.<span class="built_in">size</span>())</span><br><span class="line">        &#123;</span><br><span class="line">            res.<span class="built_in">push_back</span>(path);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = start; i &lt;= s.<span class="built_in">size</span>() - <span class="number">1</span>; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">isPalindrome</span>(s.<span class="built_in">substr</span>(start, i - start + <span class="number">1</span>)))</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">// 处理</span></span><br><span class="line">                path.<span class="built_in">push_back</span>(s.<span class="built_in">substr</span>(start, i - start + <span class="number">1</span>));</span><br><span class="line">                <span class="comment">// 递归</span></span><br><span class="line">                <span class="built_in">backtrack</span>(s, i + <span class="number">1</span>);</span><br><span class="line">                <span class="comment">// 回溯</span></span><br><span class="line">                path.<span class="built_in">pop_back</span>();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">isPalindrome</span><span class="params">(string s)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>, j = s.<span class="built_in">size</span>() - <span class="number">1</span>; i &lt; j; i++, j--)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (s[i] != s[j])</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector&lt;vector&lt;string&gt;&gt; <span class="built_in">partition</span>(string s) </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (s.<span class="built_in">size</span>() &gt;= <span class="number">1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">backtrack</span>(s, <span class="number">0</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<hr>
<h3 id="T93-复原IP地址"><a href="#T93-复原IP地址" class="headerlink" title="T93 复原IP地址"></a>T93 复原IP地址</h3><p>有效 IP 地址 正好由四个整数（每个整数位于 0 到 255 之间组成，且不能含有前导 0），整数之间用 ‘.’ 分隔。<br>例如：”0.1.2.201” 和 “192.168.1.1” 是 有效 IP 地址，但是 “0.011.255.245”、”192.168.1.312” 和 “<a href="mailto:&#49;&#x39;&#x32;&#46;&#49;&#54;&#56;&#x40;&#49;&#x2e;&#49;">&#49;&#x39;&#x32;&#46;&#49;&#54;&#56;&#x40;&#49;&#x2e;&#49;</a>“ 是 无效 IP 地址。<br>给定一个只包含数字的字符串 s ，用以表示一个 IP 地址，返回所有可能的有效 IP 地址，这些地址可以通过在 s 中插入 ‘.’ 来形成。你 不能 重新排序或删除 s 中的任何数字。你可以按 任何 顺序返回答案。<br><strong>分析</strong></p>
<ul>
<li>定参数 ： 一个路径<code>vector&lt;string&gt; path</code> 、一个结果集记录<code>vector&lt;string&gt; res（因为后面返回的也是vector&lt;string&gt; 所以这里索性直接将有效的path组合后再放进res）</code></li>
<li>定终止条件 ： 整个字符串被分割为4个有效的子串 – PATH中含有3个有效的子串，剩下的部分也是一个有效的子串</li>
<li>定搜索逻辑 ： 同上题</li>
<li><ul>
<li>特别的 如果一个子串不是有效串，那么其延长串也不会是有效串</li>
</ul>
</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> </span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    vector&lt;string&gt; res;         <span class="comment">// res 记录当前的解，不用二维数组是因为需要将其组合为x.x.x.x的形式输出,这里直接在里面放x.x.x.x</span></span><br><span class="line">    vector&lt;string&gt; path;        <span class="comment">// path 记录当前分割的结果</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">backtrack</span><span class="params">(string s, <span class="type">int</span> start)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="comment">// 终止条件是 分割成了4个串</span></span><br><span class="line">        <span class="comment">// 亦即 path 中有三个有效串 剩下的部分也是一个有效串</span></span><br><span class="line">        <span class="keyword">if</span> (path.<span class="built_in">size</span>() == <span class="number">3</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">isValid</span>(s.<span class="built_in">substr</span>(start,s.<span class="built_in">size</span>() - start)))</span><br><span class="line">            &#123;</span><br><span class="line">                res.<span class="built_in">push_back</span>(path[<span class="number">0</span>] + <span class="string">&quot;.&quot;</span> + path[<span class="number">1</span>] + <span class="string">&quot;.&quot;</span> + path[<span class="number">2</span>] + <span class="string">&quot;.&quot;</span> + s.<span class="built_in">substr</span>(start, s.<span class="built_in">size</span>() - start));</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = start; i &lt;= s.<span class="built_in">size</span>() - <span class="number">1</span>; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">isValid</span>(s.<span class="built_in">substr</span>(start, i - start + <span class="number">1</span>)))</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">// 处理 </span></span><br><span class="line">                path.<span class="built_in">push_back</span>(s.<span class="built_in">substr</span>(start, i - start + <span class="number">1</span>));</span><br><span class="line">                <span class="comment">// 递归</span></span><br><span class="line">                <span class="built_in">backtrack</span>(s, i + <span class="number">1</span>);</span><br><span class="line">                <span class="comment">// 回溯</span></span><br><span class="line">                path.<span class="built_in">pop_back</span>();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">// 这里可以BREAK的原因是</span></span><br><span class="line">                <span class="comment">// 如果一个字符串不是一个有效的串的话  那么在其后面加东西也不会让其变成有效串</span></span><br><span class="line">                <span class="comment">// 对于 s.substr(start, i - start + 1) 是空字符串的情况 这是不会出现的</span></span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">isValid</span><span class="params">(string s)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="comment">// 1. 空字符串不合法</span></span><br><span class="line">        <span class="keyword">if</span> (s.<span class="built_in">empty</span>())</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 2. 有前导0不合法</span></span><br><span class="line">        <span class="keyword">if</span> (s[<span class="number">0</span>] == <span class="string">&#x27;0&#x27;</span> &amp;&amp; s.<span class="built_in">size</span>() &gt; <span class="number">1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> sum = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt;= s.<span class="built_in">size</span>() <span class="number">-1</span> ; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (<span class="string">&#x27;0&#x27;</span> &lt;= s[i] &amp;&amp; s[i] &lt;= <span class="string">&#x27;9&#x27;</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                sum = sum * <span class="number">10</span> + (s[i] - <span class="string">&#x27;0&#x27;</span>);</span><br><span class="line">                <span class="comment">// 3. 过大的数字 不合法</span></span><br><span class="line">                <span class="keyword">if</span> (sum &gt; <span class="number">255</span>)</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 4. 有非数字字符 不合法</span></span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">      </span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;string&gt; <span class="title">restoreIpAddresses</span><span class="params">(string s)</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (s.<span class="built_in">size</span>() &gt;= <span class="number">4</span> &amp;&amp; s.<span class="built_in">size</span>() &lt;= <span class="number">12</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">backtrack</span>(s, <span class="number">0</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<hr>
<h1 id="3-子集类问题"><a href="#3-子集类问题" class="headerlink" title="3. 子集类问题"></a>3. 子集类问题</h1><p>例题 ：给你一个整数数组 nums ，数组中的元素 互不相同 。返回该数组所有可能的子集（幂集）。解集 不能 包含重复的子集。你可以按 任意顺序 返回解集。</p>
<ul>
<li>子集类问题 与 组合类问题、切割类问题 的区别在于，组合、切割在求解时结果都是叶子节点，而子集类问题的结果是全部节点</li>
<li>但是子集类问题与组合类问题存在一个共同点，即不考虑元素的顺序，所以依旧可以不妨假设按某种顺序来取得元素<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">例如 对集合 &#123;1,2,3&#125;</span><br><span class="line">1. 组合类问题 求元素数目为2的组合 结果为&#123;&#123;1,2&#125;,&#123;1,3&#125;,&#123;2,3&#125;&#125;</span><br><span class="line">搜索树</span><br><span class="line">				&#123;1,2,3&#125;</span><br><span class="line">	&#123;1&#125; 		&#123;2&#125; 		&#123;3&#125;</span><br><span class="line">&#123;1,2&#125; &#123;1,3&#125; 	&#123;2,3&#125;		X</span><br><span class="line"></span><br><span class="line">2. 子集类问题 求集合的全部子集 结果为&#123;&#123;&#125;,&#123;1&#125;,&#123;2&#125;,&#123;3&#125;,&#123;1,2&#125;,&#123;1,3&#125;,&#123;2,3&#125;,&#123;1,2,3&#125;&#125;</span><br><span class="line">搜索树：</span><br><span class="line">				&#123;1,2,3&#125;</span><br><span class="line">	&#123;1&#125; 		&#123;2&#125; 		&#123;3&#125;</span><br><span class="line">&#123;1,2&#125; 	&#123;1,3&#125; 	&#123;2,3&#125;		X</span><br><span class="line">&#123;1,2,3&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="题目-2"><a href="#题目-2" class="headerlink" title="题目"></a>题目</h2><h3 id="T78-子集"><a href="#T78-子集" class="headerlink" title="T78 子集"></a>T78 子集</h3><p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/subsets/">https://leetcode.cn/problems/subsets/</a><br>给你一个整数数组 nums ，数组中的元素 互不相同 。返回该数组所有可能的子集（幂集）。解集 不能 包含重复的子集。你可以按 任意顺序 返回解集。<br><strong>分析</strong><br>回溯法三步</p>
<ol>
<li>定参数 ： 一个存放结果的<code>vector&lt;vector&lt;int&gt;&gt; res</code>；一个存放当前路径的<code>vector&lt;int&gt; path</code>；一个记录当前决策点的<code>start</code></li>
<li>定终止条件 ： 当当前决策点时非法的，即<code>start &gt;= nums.size</code>的时候，终止函数</li>
<li>定单层搜索逻辑 ： 从[start,size()-1]尝试每个元素，下一层的搜索为 <code>i+1</code></li>
</ol>
<p><strong>代码</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> </span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; res;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; path;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">backtrack</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> start)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="comment">// 每进入到回溯函数代表搜索到了一个新的节点</span></span><br><span class="line">        <span class="comment">// 子集问题搜索所有的节点 没有限制条件</span></span><br><span class="line">        res.<span class="built_in">push_back</span>(path);</span><br><span class="line">	</span><br><span class="line">		<span class="comment">// 这里仔细分析 start &gt;= size() 是不会进下面的 for 循环的, 也就是说本来也就是会直接 return 的 所以是可以省略的</span></span><br><span class="line">        <span class="keyword">if</span> (start &gt;= nums.<span class="built_in">size</span>())</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = start; i &lt;= nums.<span class="built_in">size</span>() - <span class="number">1</span>; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// 处理 </span></span><br><span class="line">            path.<span class="built_in">push_back</span>(nums[i]);</span><br><span class="line">            <span class="comment">// 递归</span></span><br><span class="line">            <span class="built_in">backtrack</span>(nums, i + <span class="number">1</span>);</span><br><span class="line">            <span class="comment">// 回溯</span></span><br><span class="line">            path.<span class="built_in">pop_back</span>();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">subsets</span>(vector&lt;<span class="type">int</span>&gt;&amp; nums) </span><br><span class="line">    &#123;</span><br><span class="line">        res.<span class="built_in">clear</span>();</span><br><span class="line">        path.<span class="built_in">clear</span>();</span><br><span class="line">        <span class="built_in">backtrack</span>(nums, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<hr>
<h3 id="T90-子集II"><a href="#T90-子集II" class="headerlink" title="T90 子集II"></a>T90 子集II</h3><p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/subsets-ii/">https://leetcode.cn/problems/subsets-ii/</a><br>给你一个整数数组 nums ，其中可能包含重复元素，请你返回该数组所有可能的子集（幂集）。解集 不能 包含重复的子集。返回的解集中，子集可以按 任意顺序 排列。</p>
<ul>
<li>这题就是在子集问题中加入了<code>树层去重</code><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> </span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; res;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; path;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">backtrack</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> start)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        res.<span class="built_in">push_back</span>(path);</span><br><span class="line">        <span class="keyword">if</span> (start &gt;= nums.<span class="built_in">size</span>())</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// -10 &lt;= nums[i] &lt;= 10</span></span><br><span class="line">        <span class="type">int</span> last = INT_MIN;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = start; i &lt;= nums.<span class="built_in">size</span>() - <span class="number">1</span>; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// 不能选择本层已经使用过的元素</span></span><br><span class="line">            <span class="keyword">if</span> (nums[i] &gt; last)</span><br><span class="line">            &#123;</span><br><span class="line">                last = nums[i];</span><br><span class="line">                <span class="comment">// 处理</span></span><br><span class="line">                path.<span class="built_in">push_back</span>(nums[i]);</span><br><span class="line">                <span class="comment">// 递归</span></span><br><span class="line">                <span class="built_in">backtrack</span>(nums, i + <span class="number">1</span>);</span><br><span class="line">                <span class="comment">// 回溯</span></span><br><span class="line">                path.<span class="built_in">pop_back</span>();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">subsetsWithDup</span>(vector&lt;<span class="type">int</span>&gt;&amp; nums) </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 排序是去重的基础</span></span><br><span class="line">        <span class="built_in">sort</span>(nums.<span class="built_in">begin</span>(), nums.<span class="built_in">end</span>());</span><br><span class="line">        <span class="built_in">backtrack</span>(nums, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li>
</ul>
<hr>
<h1 id="4-排列类问题"><a href="#4-排列类问题" class="headerlink" title="4. 排列类问题"></a>4. 排列类问题</h1><p>例题 ： 给定一个 没有重复 数字的序列，返回其所有可能的全排列。<br>如 ：<br>输入: [1,2,3]<br>输出: [ [1,2,3], [1,3,2], [2,1,3], [2,3,1], [3,1,2], [3,2,1] ]</p>
<ul>
<li>排列问题与之前的问题的最大的不同点在于，它重视元素的顺序了</li>
<li>回溯三步骤</li>
<li><ol>
<li>定函数参数 ： 一个记录结果的<code>vector&lt;vector&lt;int&gt;&gt; res</code>， 一个记录当前路径的 <code>vector&lt;int&gt; path</code></li>
</ol>
</li>
<li><ol start="2">
<li>定终止条件 ： 当原数组的所有元素都被选择且仅被选择了一次，即 <code>path.size() = nums.size()</code></li>
</ol>
</li>
<li><ol start="3">
<li>定搜索逻辑 ： 由于是排列，那么本层的元素选取规则是 [0,nums.size()-1] 中尚未被选取的一个元素，下一层亦是如此。为了能够确定哪些元素已经被选取过了，（判断其在不在path中有点耗时），可以多加一个参数 <code>vector&lt;bool&gt; used</code>来记录每个位置的元素的选取情况</li>
</ol>
</li>
</ul>
<h3 id="T46-全排列"><a href="#T46-全排列" class="headerlink" title="T46 全排列"></a>T46 全排列</h3><p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/permutations/">https://leetcode.cn/problems/permutations/</a><br>给定一个不含重复数字的数组 nums ，返回其 所有可能的全排列 。你可以 按任意顺序 返回答案。<br><strong>代码</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> </span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; res;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; path;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">backtrack</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, vector&lt;<span class="type">bool</span>&gt;&amp; used)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (path.<span class="built_in">size</span>() == nums.<span class="built_in">size</span>())</span><br><span class="line">        &#123;</span><br><span class="line">            res.<span class="built_in">push_back</span>(path);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt;= nums.<span class="built_in">size</span>() - <span class="number">1</span>; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// 选取的是 [0,size-1] 中 used == false 的元素</span></span><br><span class="line">            <span class="keyword">if</span> (used[i] == <span class="literal">false</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">// 处理</span></span><br><span class="line">                used[i] = <span class="literal">true</span>;</span><br><span class="line">                path.<span class="built_in">push_back</span>(nums[i]);</span><br><span class="line">                <span class="comment">// 递归</span></span><br><span class="line">                <span class="built_in">backtrack</span>(nums, used);</span><br><span class="line">                <span class="comment">// 回溯</span></span><br><span class="line">                path.<span class="built_in">pop_back</span>();</span><br><span class="line">                used[i] = <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">permute</span>(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span><br><span class="line">    &#123;</span><br><span class="line">        res.<span class="built_in">clear</span>();</span><br><span class="line">        path.<span class="built_in">clear</span>();</span><br><span class="line">        <span class="function">vector&lt;<span class="type">bool</span>&gt; <span class="title">used</span><span class="params">(nums.size(), <span class="literal">false</span>)</span></span>;</span><br><span class="line">        <span class="built_in">backtrack</span>(nums, used);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<hr>
<h3 id="T47-全排列II"><a href="#T47-全排列II" class="headerlink" title="T47 全排列II"></a>T47 全排列II</h3><p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/permutations-ii/">https://leetcode.cn/problems/permutations-ii/</a><br>给定一个可包含重复数字的序列 nums ，按任意顺序 返回所有不重复的全排列</p>
<ul>
<li>排列问题 加 树层去重</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> </span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; res;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; path;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">backtrack</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, vector&lt;<span class="type">bool</span>&gt;&amp; used)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (path.<span class="built_in">size</span>() == nums.<span class="built_in">size</span>())</span><br><span class="line">        &#123;</span><br><span class="line">            res.<span class="built_in">push_back</span>(path);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// -10 &lt;= nums[i] &lt;= 10</span></span><br><span class="line">        <span class="type">int</span> last = INT_MIN;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt;= nums.<span class="built_in">size</span>() - <span class="number">1</span>; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// 可以选择的元素是 1. 尚未被选择过的 2. 当前层相同的元素只能选择一次</span></span><br><span class="line">            <span class="keyword">if</span> (used[i] == <span class="literal">false</span> &amp;&amp; nums[i] &gt; last)</span><br><span class="line">            &#123;</span><br><span class="line">                last = nums[i];</span><br><span class="line">                </span><br><span class="line">                used[i] = <span class="literal">true</span>;</span><br><span class="line">                path.<span class="built_in">push_back</span>(nums[i]);</span><br><span class="line"></span><br><span class="line">                <span class="built_in">backtrack</span>(nums, used);</span><br><span class="line"></span><br><span class="line">                path.<span class="built_in">pop_back</span>();</span><br><span class="line">                used[i] = <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">backtrack2</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, vector&lt;<span class="type">bool</span>&gt; used)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (path.<span class="built_in">size</span>() == nums.<span class="built_in">size</span>())</span><br><span class="line">        &#123;</span><br><span class="line">            res.<span class="built_in">push_back</span>(path);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt;= nums.<span class="built_in">size</span>() - <span class="number">1</span>; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// 再次思考 used 数组的含义 </span></span><br><span class="line">            <span class="comment">// used = true 说明该元素已经被使用过了 而且是在 当前所处的树枝上被使用过了</span></span><br><span class="line">            <span class="comment">// used = false 说明该元素尚未被使用 但是在 当前树层上可能被使用</span></span><br><span class="line">            <span class="comment">// 那么 树层去重 - 当前层重复的元素只能选择一次</span></span><br><span class="line">            <span class="comment">// 换个说法 used = false 的元素(即当前层可使用的元素)中，</span></span><br><span class="line">            <span class="comment">// 对于 元素nums[i] ，如果其前面存在一个元素 nums[i-1] 也可以在本层使用</span></span><br><span class="line">            <span class="comment">// 那么按规则应该使用的是 i-1 而不是 i, 所以其不应该被使用</span></span><br><span class="line">            <span class="keyword">if</span> (i &gt; <span class="number">0</span> &amp;&amp; nums[i] == nums[i - <span class="number">1</span>] &amp;&amp; used[i - <span class="number">1</span>] == <span class="literal">false</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (used[i] == <span class="literal">false</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                used[i] = <span class="literal">true</span>;</span><br><span class="line">                path.<span class="built_in">push_back</span>(nums[i]);</span><br><span class="line"></span><br><span class="line">                <span class="built_in">backtrack</span>(nums, used);</span><br><span class="line"></span><br><span class="line">                path.<span class="built_in">pop_back</span>();</span><br><span class="line">                used[i] = <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">permuteUnique</span>(vector&lt;<span class="type">int</span>&gt;&amp; nums) </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">sort</span>(nums.<span class="built_in">begin</span>(), nums.<span class="built_in">end</span>());</span><br><span class="line">        <span class="function">vector&lt;<span class="type">bool</span>&gt; <span class="title">used</span><span class="params">(nums.size(), <span class="literal">false</span>)</span></span>;</span><br><span class="line">        <span class="built_in">backtrack2</span>(nums, used);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

















<hr>
<h1 id="回溯算法总结"><a href="#回溯算法总结" class="headerlink" title="回溯算法总结"></a>回溯算法总结</h1><h2 id="1-回溯算法的性能分析"><a href="#1-回溯算法的性能分析" class="headerlink" title="1. 回溯算法的性能分析"></a>1. 回溯算法的性能分析</h2><ul>
<li>回溯算法基于的是在解空间上的深度优先遍历，其解空间&#x2F;搜索路径又可以被视为一颗树，那么其时间复杂度可以认为是 <code>实际搜索生成的节点数目 * 在每个节点上的处理时间复杂度</code> ， 同时因为回溯算法针对不同的问题有着不同的细节上的搜索策略，因而对于实际问题，其实际的时间复杂度是需要实际分析的，不过由于本质是穷举的特性，其时间复杂度一般为<code>指数级时间复杂度</code></li>
</ul>
<p>对于组合类问题<br>  前文说过组合类问题的可以改为顺序选取问题，那么依次考虑顺序，每个元素只可能选&#x2F;不选，每种状态即对应搜索树的一个节点，那么实际搜索的节点数目为<code>2^N</code>，而构造的每一个子组合都需要被处理，即一共有</p>
<p><strong>暂时放在这里 先做点题 看不懂 。。。</strong><br>子集问题分析：</p>
<p>时间复杂度：O(n * 2n)，因为每一个元素的状态无外乎取与不取，所以时间复杂度为O(2n)，构造每一组子集都需要填进数组，又有需要O(n)，最终时间复杂度：O(n * 2^n)<br>空间复杂度：O(n)，递归深度为n，所以系统栈所用空间为O(n)，每一层递归所用的空间都是常数级别，注意代码里的result和path都是全局变量，就算是放在参数里，传的也是引用，并不会新申请内存空间，最终空间复杂度为O(n)<br>排列问题分析：</p>
<p>时间复杂度：O(n!)，这个可以从排列的树形图中很明显发现，每一层节点为n，第二层每一个分支都延伸了n-1个分支，再往下又是n-2个分支，所以一直到叶子节点一共就是 n * n-1 * n-2 * … 1 &#x3D; n!。<br>空间复杂度：O(n)，和子集问题同理。<br>组合问题分析：</p>
<p>时间复杂度：O(n * 2^n)，组合问题其实就是一种子集的问题，所以组合问题最坏的情况，也不会超过子集问题的时间复杂度。<br>空间复杂度：O(n)，和子集问题同理。<br>N皇后问题分析：</p>
<p>时间复杂度：O(n!) ，其实如果看树形图的话，直觉上是O(n^n)，但皇后之间不能见面所以在搜索的过程中是有剪枝的，最差也就是O（n!），n!表示n * (n-1) * … * 1。<br>空间复杂度：O(n)，和子集问题同理。<br>解数独问题分析：</p>
<p>时间复杂度：O(9^m) , m是’.’的数目。<br>空间复杂度：O(n2)，递归的深度是n2<br>「一般说道回溯算法的复杂度，都说是指数级别的时间复杂度，这也算是一个概括吧！」<br>————————————————<br>版权声明：本文为CSDN博主「想名字多费事」的原创文章，遵循CC 4.0 BY-SA版权协议，转载请附上原文出处链接及本声明。<br>原文链接：<a target="_blank" rel="noopener" href="https://blog.csdn.net/weixin_46269257/article/details/117129706">https://blog.csdn.net/weixin_46269257/article/details/117129706</a></p>

      </div>
      
        <div class="prev-or-next">
          <div class="post-foot-next">
            
              <a href="/2022/07/11/%E7%AC%94%E8%AF%95%E9%9D%A2%E8%AF%95/%E7%AC%94%E8%AF%95%E7%BB%8F%E5%8E%86%E5%8F%8B%E5%A1%94%E6%B8%B8%E6%88%8F/" target="_self">
                <i class="iconfont icon-chevronleft"></i>
                <span>上一页</span>
              </a>
            
          </div>
          <div class="post-attach">
            <span class="post-pubtime">
              <i class="iconfont icon-updatetime" title="更新时间"></i>
              2022-07-13 15:35:37
            </span>
            
                  <span class="post-tags">
                    <i class="iconfont icon-tags" title="标签"></i>
                    
                    <span class="span--tag">
                      <a href="/tags/%E9%9D%A2%E8%AF%95/" title="面试">
                        <b>#</b> 面试
                      </a>
                    </span>
                    
                    <span class="span--tag">
                      <a href="/tags/C/" title="C++">
                        <b>#</b> C++
                      </a>
                    </span>
                    
                    <span class="span--tag">
                      <a href="/tags/%E7%AE%97%E6%B3%95/" title="算法">
                        <b>#</b> 算法
                      </a>
                    </span>
                    
                  </span>
              
          </div>
          <div class="post-foot-prev">
            
              <a href="/2022/07/14/C++%E5%9F%BA%E7%A1%80/C-%E4%B9%8B%E6%B3%9B%E5%9E%8B%E7%BC%96%E7%A8%8B/" target="_self">
                <span>下一页</span>
                <i class="iconfont icon-chevronright"></i>
              </a>
            
          </div>
        </div>
      
    </div>
    
  <div id="btn-catalog" class="btn-catalog">
    <i class="iconfont icon-catalog"></i>
  </div>
  <div class="post-catalog hidden" id="catalog">
    <div class="title">目录</div>
    <div class="catalog-content">
      
        <ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%90%86%E8%AE%BA%E5%9F%BA%E7%A1%80"><span class="toc-text">理论基础</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#1-%E7%BB%84%E5%90%88%E7%B1%BB%E9%97%AE%E9%A2%98"><span class="toc-text">1. 组合类问题</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%A2%98%E7%9B%AE"><span class="toc-text">题目</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#T77-%E7%BB%84%E5%90%88"><span class="toc-text">T77 组合</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#T216-%E7%BB%84%E5%90%88%E6%80%BB%E5%92%8CIII"><span class="toc-text">T216 组合总和III</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#T17-%E7%94%B5%E8%AF%9D%E5%8F%B7%E7%A0%81%E7%9A%84%E5%AD%97%E6%AF%8D%E7%BB%84%E5%90%88"><span class="toc-text">T17 电话号码的字母组合</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#T39-%E7%BB%84%E5%90%88%E6%80%BB%E5%92%8C"><span class="toc-text">T39 组合总和</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#T40-%E7%BB%84%E5%90%88%E6%80%BB%E5%92%8C"><span class="toc-text">T40 组合总和</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#2-%E5%88%87%E5%89%B2%E9%97%AE%E9%A2%98"><span class="toc-text">2. 切割问题</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%90%86%E8%AE%BA%E9%83%A8%E5%88%86"><span class="toc-text">理论部分</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%A2%98%E7%9B%AE-1"><span class="toc-text">题目</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#T131-%E5%88%86%E5%89%B2%E5%9B%9E%E6%96%87%E4%B8%B2"><span class="toc-text">T131 分割回文串</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#T93-%E5%A4%8D%E5%8E%9FIP%E5%9C%B0%E5%9D%80"><span class="toc-text">T93 复原IP地址</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#3-%E5%AD%90%E9%9B%86%E7%B1%BB%E9%97%AE%E9%A2%98"><span class="toc-text">3. 子集类问题</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%A2%98%E7%9B%AE-2"><span class="toc-text">题目</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#T78-%E5%AD%90%E9%9B%86"><span class="toc-text">T78 子集</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#T90-%E5%AD%90%E9%9B%86II"><span class="toc-text">T90 子集II</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#4-%E6%8E%92%E5%88%97%E7%B1%BB%E9%97%AE%E9%A2%98"><span class="toc-text">4. 排列类问题</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#T46-%E5%85%A8%E6%8E%92%E5%88%97"><span class="toc-text">T46 全排列</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#T47-%E5%85%A8%E6%8E%92%E5%88%97II"><span class="toc-text">T47 全排列II</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%9B%9E%E6%BA%AF%E7%AE%97%E6%B3%95%E6%80%BB%E7%BB%93"><span class="toc-text">回溯算法总结</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1-%E5%9B%9E%E6%BA%AF%E7%AE%97%E6%B3%95%E7%9A%84%E6%80%A7%E8%83%BD%E5%88%86%E6%9E%90"><span class="toc-text">1. 回溯算法的性能分析</span></a></li></ol></li></ol>
      
    </div>
  </div>

  
<script src="/js/catalog.js"></script>




    
      <div class="comments-container">
        




  
    <script async type="text/javascript" src="/plugins/valine.min.js" onload="loadValineSuc(this)"></script>
  

  <div id="vcomments"></div>

  <script>
    function loadValineSuc() {
      new Valine({
        el: '#vcomments',
        appId: 'tJWAP21HnTAP3J9RodjBmGKN-gzGzoHsz',
        appKey: 'O55G5efQpW0frrpnzt7gFMsa',
        placeholder: 'Welcome!',
        avatar: 'retro',
        lang: 'zh-CN'
      })
    }
  </script>

    <style>
      .comments-container .v .vempty {
        display: none!important;
      }
    </style>




      </div>
    
  </div>


        
<div class="footer">
  <div class="social">
    <ul>
      
        <li>
          <a title="github" target="_blank" rel="noopener" href="https://github.com/MoyiHP">
            <i class="iconfont icon-github"></i>
          </a>
        </li>
      
    </ul>
  </div>
  
    
    <div class="footer-more">
      
        <a target="_blank" rel="noopener" href="https://github.com/zchengsite/hexo-theme-oranges">Copyright © 2023 Oranges</a>
        
    </div>
  
    
    <div class="footer-more">
      
        <a target="_blank" rel="noopener" href="https://github.com/zchengsite/hexo-theme-oranges">Theme by Oranges | Powered by Hexo</a>
        
    </div>
  
</div>

      </div>

      <div class="tools-bar">
        <div class="back-to-top tools-bar-item hidden">
  <a href="javascript: void(0)">
    <i class="iconfont icon-chevronup"></i>
  </a>
</div>


<script src="/js/backtotop.js"></script>



        
  <div class="search-icon tools-bar-item" id="search-icon">
    <a href="javascript: void(0)">
      <i class="iconfont icon-search"></i>
    </a>
  </div>

  <div class="search-overlay hidden">
    <div class="search-content" tabindex="0">
      <div class="search-title">
        <span class="search-icon-input">
          <a href="javascript: void(0)">
            <i class="iconfont icon-search"></i>
          </a>
        </span>
        
          <input type="text" class="search-input" id="search-input" placeholder="搜索...">
        
        <span class="search-close-icon" id="search-close-icon">
          <a href="javascript: void(0)">
            <i class="iconfont icon-close"></i>
          </a>
        </span>
      </div>
      <div class="search-result" id="search-result"></div>
    </div>
  </div>

  <script type="text/javascript">
    var inputArea = document.querySelector("#search-input")
    var searchOverlayArea = document.querySelector(".search-overlay")

    inputArea.onclick = function() {
      getSearchFile()
      this.onclick = null
    }

    inputArea.onkeydown = function() {
      if(event.keyCode == 13)
        return false
    }

    function openOrHideSearchContent() {
      let isHidden = searchOverlayArea.classList.contains('hidden')
      if (isHidden) {
        searchOverlayArea.classList.remove('hidden')
        document.body.classList.add('hidden')
        // inputArea.focus()
      } else {
        searchOverlayArea.classList.add('hidden')
        document.body.classList.remove('hidden')
      }
    }

    function blurSearchContent(e) {
      if (e.target === searchOverlayArea) {
        openOrHideSearchContent()
      }
    }

    document.querySelector("#search-icon").addEventListener("click", openOrHideSearchContent, false)
    document.querySelector("#search-close-icon").addEventListener("click", openOrHideSearchContent, false)
    searchOverlayArea.addEventListener("click", blurSearchContent, false)

    var searchFunc = function (path, search_id, content_id) {
      'use strict';
      var $input = document.getElementById(search_id);
      var $resultContent = document.getElementById(content_id);
      $resultContent.innerHTML = "<ul><span class='local-search-empty'>首次搜索，正在载入索引文件，请稍后……<span></ul>";
      $.ajax({
        // 0x01. load xml file
        url: path,
        dataType: "xml",
        success: function (xmlResponse) {
          // 0x02. parse xml file
          var datas = $("entry", xmlResponse).map(function () {
            return {
              title: $("title", this).text(),
              content: $("content", this).text(),
              url: $("url", this).text()
            };
          }).get();
          $resultContent.innerHTML = "";

          $input.addEventListener('input', function () {
            // 0x03. parse query to keywords list
            var str = '<ul class=\"search-result-list\">';
            var keywords = this.value.trim().toLowerCase().split(/[\s\-]+/);
            $resultContent.innerHTML = "";
            if (this.value.trim().length <= 0) {
              return;
            }
            // 0x04. perform local searching
            datas.forEach(function (data) {
              var isMatch = true;
              var content_index = [];
              if (!data.title || data.title.trim() === '') {
                data.title = "Untitled";
              }
              var orig_data_title = data.title.trim();
              var data_title = orig_data_title.toLowerCase();
              var orig_data_content = data.content.trim().replace(/<[^>]+>/g, "");
              var data_content = orig_data_content.toLowerCase();
              var data_url = data.url;
              var index_title = -1;
              var index_content = -1;
              var first_occur = -1;
              // only match artiles with not empty contents
              if (data_content !== '') {
                keywords.forEach(function (keyword, i) {
                  index_title = data_title.indexOf(keyword);
                  index_content = data_content.indexOf(keyword);

                  if (index_title < 0 && index_content < 0) {
                    isMatch = false;
                  } else {
                    if (index_content < 0) {
                      index_content = 0;
                    }
                    if (i == 0) {
                      first_occur = index_content;
                    }
                    // content_index.push({index_content:index_content, keyword_len:keyword_len});
                  }
                });
              } else {
                isMatch = false;
              }
              // 0x05. show search results
              if (isMatch) {
                str += "<li><a href='" + data_url + "' class='search-result-title'>" + orig_data_title + "</a>";
                var content = orig_data_content;
                if (first_occur >= 0) {
                  // cut out 100 characters
                  var start = first_occur - 20;
                  var end = first_occur + 80;

                  if (start < 0) {
                    start = 0;
                  }

                  if (start == 0) {
                    end = 100;
                  }

                  if (end > content.length) {
                    end = content.length;
                  }

                  var match_content = content.substr(start, end);

                  // highlight all keywords
                  keywords.forEach(function (keyword) {
                    var regS = new RegExp(keyword, "gi");
                    match_content = match_content.replace(regS, "<span class=\"search-keyword\">" + keyword + "</span>");
                  });

                  str += "<p class=\"search-result-abstract\">" + match_content + "...</p>"
                }
                str += "</li>";
              }
            });
            str += "</ul>";
            if (str.indexOf('<li>') === -1) {
              return $resultContent.innerHTML = "<ul><span class='local-search-empty'>没有找到内容，请尝试更换检索词。<span></ul>";
            }
            $resultContent.innerHTML = str;
          });
        },
        error: function(xhr, status, error) {
          $resultContent.innerHTML = ""
          if (xhr.status === 404) {
            $resultContent.innerHTML = "<ul><span class='local-search-empty'>未找到search.xml文件，具体请参考：<a href='https://github.com/zchengsite/hexo-theme-oranges#configuration' target='_black'>configuration</a><span></ul>";
          } else {
            $resultContent.innerHTML = "<ul><span class='local-search-empty'>请求失败，尝试重新刷新页面或稍后重试。<span></ul>";
          }
        }
      });
      $(document).on('click', '#search-close-icon', function() {
        $('#search-input').val('');
        $('#search-result').html('');
      });
    }

    var getSearchFile = function() {
        var path = "/search.xml";
        searchFunc(path, 'search-input', 'search-result');
    }
  </script>




        
  <div class="tools-bar-item theme-icon" id="switch-color-scheme">
    <a href="javascript: void(0)">
      <i id="theme-icon" class="iconfont icon-moon"></i>
    </a>
  </div>

  
<script src="/js/colorscheme.js"></script>





        

      </div>
    </div>
  
        <style>
            [bg-lazy] {
                background-image: none !important;
                background-color: #eee !important;
            }
        </style>
        <script>
            window.imageLazyLoadSetting = {
                isSPA: false,
                preloadRatio: 1,
                processImages: null,
            };
        </script><script>window.addEventListener("load",function(){var t=/\.(gif|jpg|jpeg|tiff|png)$/i,r=/^data:image\/[a-z]+;base64,/;Array.prototype.slice.call(document.querySelectorAll("img[data-original]")).forEach(function(a){var e=a.parentNode;"A"===e.tagName&&(e.href.match(t)||e.href.match(r))&&(e.href=a.dataset.original)})});</script><script>!function(r){r.imageLazyLoadSetting.processImages=t;var e=r.imageLazyLoadSetting.isSPA,n=r.imageLazyLoadSetting.preloadRatio||1,c=a();function a(){var t=Array.prototype.slice.call(document.querySelectorAll("img[data-original]")),e=Array.prototype.slice.call(document.querySelectorAll("[bg-lazy]"));return t.concat(e)}function t(){e&&(c=a());for(var t,o=0;o<c.length;o++)0<=(t=(t=c[o]).getBoundingClientRect()).bottom&&0<=t.left&&t.top<=(r.innerHeight*n||document.documentElement.clientHeight*n)&&function(){var t,e,n,a,i=c[o];e=function(){c=c.filter(function(t){return i!==t}),r.imageLazyLoadSetting.onImageLoaded&&r.imageLazyLoadSetting.onImageLoaded(i)},(t=i).hasAttribute("bg-lazy")?(t.removeAttribute("bg-lazy"),e&&e()):(n=new Image,a=t.getAttribute("data-original"),n.onload=function(){t.src=a,t.removeAttribute("data-original"),e&&e()},t.src!==a&&(n.src=a))}()}function i(){clearTimeout(t.tId),t.tId=setTimeout(t,500)}t(),document.addEventListener("scroll",i),r.addEventListener("resize",i),r.addEventListener("orientationchange",i)}(this);</script></body>
</html>
